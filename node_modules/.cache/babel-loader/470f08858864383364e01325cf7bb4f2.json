{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */function (_super) {\n  __extends(MultiPolygon, _super);\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.\n   */\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n    var _this = _super.call(this) || this;\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    _this.endss_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.flatInteriorPointsRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.orientedFlatCoordinates_ = null;\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = _this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */coordinates;\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      _this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */coordinates);\n      _this.endss_ = opt_endss;\n    } else {\n      _this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */coordinates, opt_layout);\n    }\n    return _this;\n  }\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function (polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  MultiPolygon.prototype.clone = function () {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n    var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n    multiPolygon.applyProperties(this);\n    return multiPolygon;\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  MultiPolygon.prototype.containsXY = function (x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function () {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  };\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function () {\n    return this.endss_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function () {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function () {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function (index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  MultiPolygon.prototype.getType = function () {\n    return 'MultiPolygon';\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function (extent) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n  return MultiPolygon;\n}(SimpleGeometry);\nexport default MultiPolygon;","map":{"version":3,"sources":["../src/geom/MultiPolygon.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta, } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray, } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */ (function (_super) {\n    __extends(MultiPolygon, _super);\n    /**\n     * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.\n     */\n    function MultiPolygon(coordinates, opt_layout, opt_endss) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.endss_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointsRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (!opt_endss && !Array.isArray(coordinates[0])) {\n            var layout = _this.getLayout();\n            var polygons = /** @type {Array<Polygon>} */ (coordinates);\n            var flatCoordinates = [];\n            var endss = [];\n            for (var i = 0, ii = polygons.length; i < ii; ++i) {\n                var polygon = polygons[i];\n                if (i === 0) {\n                    layout = polygon.getLayout();\n                }\n                var offset = flatCoordinates.length;\n                var ends = polygon.getEnds();\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] += offset;\n                }\n                extend(flatCoordinates, polygon.getFlatCoordinates());\n                endss.push(ends);\n            }\n            opt_layout = layout;\n            coordinates = flatCoordinates;\n            opt_endss = endss;\n        }\n        if (opt_layout !== undefined && opt_endss) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.endss_ = opt_endss;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed polygon to this multipolygon.\n     * @param {Polygon} polygon Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.appendPolygon = function (polygon) {\n        /** @type {Array<number>} */\n        var ends;\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = polygon.getFlatCoordinates().slice();\n            ends = polygon.getEnds().slice();\n            this.endss_.push();\n        }\n        else {\n            var offset = this.flatCoordinates.length;\n            extend(this.flatCoordinates, polygon.getFlatCoordinates());\n            ends = polygon.getEnds().slice();\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] += offset;\n            }\n        }\n        this.endss_.push(ends);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPolygon} Clone.\n     * @api\n     */\n    MultiPolygon.prototype.clone = function () {\n        var len = this.endss_.length;\n        var newEndss = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            newEndss[i] = this.endss_[i].slice();\n        }\n        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n        multiPolygon.applyProperties(this);\n        return multiPolygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    MultiPolygon.prototype.containsXY = function (x, y) {\n        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the multipolygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    MultiPolygon.prototype.getArea = function () {\n        return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for multi-polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n     * @api\n     */\n    MultiPolygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n    };\n    /**\n     * @return {Array<Array<number>>} Endss.\n     */\n    MultiPolygon.prototype.getEndss = function () {\n        return this.endss_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    MultiPolygon.prototype.getFlatInteriorPoints = function () {\n        if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n            var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n            this.flatInteriorPointsRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n     * @return {MultiPoint} Interior points as XYM coordinates, where M is\n     * the length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    MultiPolygon.prototype.getInteriorPoints = function () {\n        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiPolygon} Simplified MultiPolygon.\n     * @protected\n     */\n    MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEndss = [];\n        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n    };\n    /**\n     * Return the polygon at the specified index.\n     * @param {number} index Index.\n     * @return {Polygon} Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygon = function (index) {\n        if (index < 0 || this.endss_.length <= index) {\n            return null;\n        }\n        var offset;\n        if (index === 0) {\n            offset = 0;\n        }\n        else {\n            var prevEnds = this.endss_[index - 1];\n            offset = prevEnds[prevEnds.length - 1];\n        }\n        var ends = this.endss_[index].slice();\n        var end = ends[ends.length - 1];\n        if (offset !== 0) {\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] -= offset;\n            }\n        }\n        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n    };\n    /**\n     * Return the polygons of this multipolygon.\n     * @return {Array<Polygon>} Polygons.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygons = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var endss = this.endss_;\n        var polygons = [];\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var ends = endss[i].slice();\n            var end = ends[ends.length - 1];\n            if (offset !== 0) {\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] -= offset;\n                }\n            }\n            var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n            polygons.push(polygon);\n            offset = end;\n        }\n        return polygons;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPolygon.prototype.getType = function () {\n        return 'MultiPolygon';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPolygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multipolygon.\n     * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 3);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n        if (endss.length === 0) {\n            this.flatCoordinates.length = 0;\n        }\n        else {\n            var lastEnds = endss[endss.length - 1];\n            this.flatCoordinates.length =\n                lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n        }\n        this.changed();\n    };\n    return MultiPolygon;\n}(SimpleGeometry));\nexport default MultiPolygon;\n//# sourceMappingURL=MultiPolygon.js.map"]},"metadata":{},"sourceType":"module"}