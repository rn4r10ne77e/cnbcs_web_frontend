{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nvar CanvasBuilder = /** @class */function (_super) {\n  __extends(CanvasBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this) || this;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    _this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    _this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */{};\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n  CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {\n    var extent = this.getBufferedMaxExtent();\n    var tmpCoord = this.tmpCoordinate_;\n    var coordinates = this.coordinates;\n    var myEnd = coordinates.length;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var coordinates = this.coordinates;\n    var myEnd = coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    var lastXCoord = flatCoordinates[offset];\n    var lastYCoord = flatCoordinates[offset + 1];\n    var nextCoord = this.tmpCoordinate_;\n    var skipped = true;\n    var i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n    // Last coordinate equals first or only one point to append:\n    if (closed && skipped || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   */\n  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var builderBegin = this.coordinates.length;\n    var flatCoordinates, builderEnd, builderEnds, builderEndss;\n    var offset;\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getOrientedFlatCoordinates();\n        builderEndss = [];\n        var endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getEndss();\n        offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n          var myEnds = [];\n          offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n          builderEndss.push(myEnds);\n        }\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);\n        break;\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates = type == 'Polygon' ? /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds(), stride, builderEnds);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);\n        break;\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        break;\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n        if (builderEnd > builderBegin) {\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        }\n        break;\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);\n        break;\n      default:\n    }\n    this.endGeometry(feature);\n  };\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  CanvasBuilder.prototype.finish = function () {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n    var hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {import(\"./Instruction.js\").default} */instruction[0];\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n    var state = this.state;\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n  CanvasBuilder.prototype.createFill = function (state) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  CanvasBuilder.prototype.applyStroke = function (state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  CanvasBuilder.prototype.createStroke = function (state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n    var fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasBuilder.prototype.endGeometry = function (feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  };\n  return CanvasBuilder;\n}(VectorContext);\nexport default CanvasBuilder;","map":{"version":3,"sources":["../../src/render/canvas/Builder.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship, } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray, } from '../../geom/flat/inflate.js';\nvar CanvasBuilder = /** @class */ (function (_super) {\n    __extends(CanvasBuilder, _super);\n    /**\n     * @param {number} tolerance Tolerance.\n     * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     */\n    function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.tolerance = tolerance;\n        /**\n         * @protected\n         * @const\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.maxExtent = maxExtent;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.maxLineWidth = 0;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        _this.resolution = resolution;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction1_ = null;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction2_ = null;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.bufferedMaxExtent_ = null;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.instructions = [];\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.coordinates = [];\n        /**\n         * @private\n         * @type {import(\"../../coordinate.js\").Coordinate}\n         */\n        _this.tmpCoordinate_ = [];\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.hitDetectionInstructions = [];\n        /**\n         * @protected\n         * @type {import(\"../canvas.js\").FillStrokeState}\n         */\n        _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {Array<number>} dashArray Dash array.\n     * @return {Array<number>} Dash array with pixel ratio applied\n     */\n    CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n        var pixelRatio = this.pixelRatio;\n        return pixelRatio == 1\n            ? dashArray\n            : dashArray.map(function (dash) {\n                return dash * pixelRatio;\n            });\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} stride Stride.\n     * @protected\n     * @return {number} My end\n     */\n    CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {\n        var extent = this.getBufferedMaxExtent();\n        var tmpCoord = this.tmpCoordinate_;\n        var coordinates = this.coordinates;\n        var myEnd = coordinates.length;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            tmpCoord[0] = flatCoordinates[i];\n            tmpCoord[1] = flatCoordinates[i + 1];\n            if (containsCoordinate(extent, tmpCoord)) {\n                coordinates[myEnd++] = tmpCoord[0];\n                coordinates[myEnd++] = tmpCoord[1];\n            }\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} closed Last input coordinate equals first.\n     * @param {boolean} skipFirst Skip first coordinate.\n     * @protected\n     * @return {number} My end.\n     */\n    CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n        var coordinates = this.coordinates;\n        var myEnd = coordinates.length;\n        var extent = this.getBufferedMaxExtent();\n        if (skipFirst) {\n            offset += stride;\n        }\n        var lastXCoord = flatCoordinates[offset];\n        var lastYCoord = flatCoordinates[offset + 1];\n        var nextCoord = this.tmpCoordinate_;\n        var skipped = true;\n        var i, lastRel, nextRel;\n        for (i = offset + stride; i < end; i += stride) {\n            nextCoord[0] = flatCoordinates[i];\n            nextCoord[1] = flatCoordinates[i + 1];\n            nextRel = coordinateRelationship(extent, nextCoord);\n            if (nextRel !== lastRel) {\n                if (skipped) {\n                    coordinates[myEnd++] = lastXCoord;\n                    coordinates[myEnd++] = lastYCoord;\n                    skipped = false;\n                }\n                coordinates[myEnd++] = nextCoord[0];\n                coordinates[myEnd++] = nextCoord[1];\n            }\n            else if (nextRel === Relationship.INTERSECTING) {\n                coordinates[myEnd++] = nextCoord[0];\n                coordinates[myEnd++] = nextCoord[1];\n                skipped = false;\n            }\n            else {\n                skipped = true;\n            }\n            lastXCoord = nextCoord[0];\n            lastYCoord = nextCoord[1];\n            lastRel = nextRel;\n        }\n        // Last coordinate equals first or only one point to append:\n        if ((closed && skipped) || i === offset + stride) {\n            coordinates[myEnd++] = lastXCoord;\n            coordinates[myEnd++] = lastYCoord;\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} builderEnds Builder ends.\n     * @return {number} Offset.\n     */\n    CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n            builderEnds.push(builderEnd);\n            offset = end;\n        }\n        return offset;\n    };\n    /**\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {Function} renderer Renderer.\n     * @param {Function} hitDetectionRenderer Renderer.\n     */\n    CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {\n        this.beginGeometry(geometry, feature);\n        var type = geometry.getType();\n        var stride = geometry.getStride();\n        var builderBegin = this.coordinates.length;\n        var flatCoordinates, builderEnd, builderEnds, builderEndss;\n        var offset;\n        switch (type) {\n            case 'MultiPolygon':\n                flatCoordinates =\n                    /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getOrientedFlatCoordinates();\n                builderEndss = [];\n                var endss = \n                /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getEndss();\n                offset = 0;\n                for (var i = 0, ii = endss.length; i < ii; ++i) {\n                    var myEnds = [];\n                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n                    builderEndss.push(myEnds);\n                }\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEndss,\n                    geometry,\n                    renderer,\n                    inflateMultiCoordinatesArray,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEndss,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateMultiCoordinatesArray,\n                ]);\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                builderEnds = [];\n                flatCoordinates =\n                    type == 'Polygon'\n                        ? /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getOrientedFlatCoordinates()\n                        : geometry.getFlatCoordinates();\n                offset = this.drawCustomCoordinates_(flatCoordinates, 0, \n                /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (geometry).getEnds(), stride, builderEnds);\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnds,\n                    geometry,\n                    renderer,\n                    inflateCoordinatesArray,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnds,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateCoordinatesArray,\n                ]);\n                break;\n            case 'LineString':\n            case 'Circle':\n                flatCoordinates = geometry.getFlatCoordinates();\n                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    renderer,\n                    inflateCoordinates,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateCoordinates,\n                ]);\n                break;\n            case 'MultiPoint':\n                flatCoordinates = geometry.getFlatCoordinates();\n                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n                if (builderEnd > builderBegin) {\n                    this.instructions.push([\n                        CanvasInstruction.CUSTOM,\n                        builderBegin,\n                        builderEnd,\n                        geometry,\n                        renderer,\n                        inflateCoordinates,\n                    ]);\n                    this.hitDetectionInstructions.push([\n                        CanvasInstruction.CUSTOM,\n                        builderBegin,\n                        builderEnd,\n                        geometry,\n                        hitDetectionRenderer || renderer,\n                        inflateCoordinates,\n                    ]);\n                }\n                break;\n            case 'Point':\n                flatCoordinates = geometry.getFlatCoordinates();\n                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n                builderEnd = this.coordinates.length;\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    renderer,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                ]);\n                break;\n            default:\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @protected\n     * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n        this.beginGeometryInstruction1_ = [\n            CanvasInstruction.BEGIN_GEOMETRY,\n            feature,\n            0,\n            geometry,\n        ];\n        this.instructions.push(this.beginGeometryInstruction1_);\n        this.beginGeometryInstruction2_ = [\n            CanvasInstruction.BEGIN_GEOMETRY,\n            feature,\n            0,\n            geometry,\n        ];\n        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n    };\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n    CanvasBuilder.prototype.finish = function () {\n        return {\n            instructions: this.instructions,\n            hitDetectionInstructions: this.hitDetectionInstructions,\n            coordinates: this.coordinates,\n        };\n    };\n    /**\n     * Reverse the hit detection instructions.\n     */\n    CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n        var hitDetectionInstructions = this.hitDetectionInstructions;\n        // step 1 - reverse array\n        hitDetectionInstructions.reverse();\n        // step 2 - reverse instructions within geometry blocks\n        var i;\n        var n = hitDetectionInstructions.length;\n        var instruction;\n        var type;\n        var begin = -1;\n        for (i = 0; i < n; ++i) {\n            instruction = hitDetectionInstructions[i];\n            type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            if (type == CanvasInstruction.END_GEOMETRY) {\n                begin = i;\n            }\n            else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n                instruction[2] = i;\n                reverseSubArray(this.hitDetectionInstructions, begin, i);\n                begin = -1;\n            }\n        }\n    };\n    /**\n     * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n    CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n        var state = this.state;\n        if (fillStyle) {\n            var fillStyleColor = fillStyle.getColor();\n            state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n        }\n        else {\n            state.fillStyle = undefined;\n        }\n        if (strokeStyle) {\n            var strokeStyleColor = strokeStyle.getColor();\n            state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n            var strokeStyleLineCap = strokeStyle.getLineCap();\n            state.lineCap =\n                strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n            var strokeStyleLineDash = strokeStyle.getLineDash();\n            state.lineDash = strokeStyleLineDash\n                ? strokeStyleLineDash.slice()\n                : defaultLineDash;\n            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n            state.lineDashOffset = strokeStyleLineDashOffset\n                ? strokeStyleLineDashOffset\n                : defaultLineDashOffset;\n            var strokeStyleLineJoin = strokeStyle.getLineJoin();\n            state.lineJoin =\n                strokeStyleLineJoin !== undefined\n                    ? strokeStyleLineJoin\n                    : defaultLineJoin;\n            var strokeStyleWidth = strokeStyle.getWidth();\n            state.lineWidth =\n                strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n            state.miterLimit =\n                strokeStyleMiterLimit !== undefined\n                    ? strokeStyleMiterLimit\n                    : defaultMiterLimit;\n            if (state.lineWidth > this.maxLineWidth) {\n                this.maxLineWidth = state.lineWidth;\n                // invalidate the buffered max extent cache\n                this.bufferedMaxExtent_ = null;\n            }\n        }\n        else {\n            state.strokeStyle = undefined;\n            state.lineCap = undefined;\n            state.lineDash = null;\n            state.lineDashOffset = undefined;\n            state.lineJoin = undefined;\n            state.lineWidth = undefined;\n            state.miterLimit = undefined;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Fill instruction.\n     */\n    CanvasBuilder.prototype.createFill = function (state) {\n        var fillStyle = state.fillStyle;\n        /** @type {Array<*>} */\n        var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n        if (typeof fillStyle !== 'string') {\n            // Fill is a pattern or gradient - align it!\n            fillInstruction.push(true);\n        }\n        return fillInstruction;\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     */\n    CanvasBuilder.prototype.applyStroke = function (state) {\n        this.instructions.push(this.createStroke(state));\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Stroke instruction.\n     */\n    CanvasBuilder.prototype.createStroke = function (state) {\n        return [\n            CanvasInstruction.SET_STROKE_STYLE,\n            state.strokeStyle,\n            state.lineWidth * this.pixelRatio,\n            state.lineCap,\n            state.lineJoin,\n            state.miterLimit,\n            this.applyPixelRatio(state.lineDash),\n            state.lineDashOffset * this.pixelRatio,\n        ];\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n     */\n    CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n        var fillStyle = state.fillStyle;\n        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n            if (fillStyle !== undefined) {\n                this.instructions.push(createFill.call(this, state));\n            }\n            state.currentFillStyle = fillStyle;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n     */\n    CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n        var strokeStyle = state.strokeStyle;\n        var lineCap = state.lineCap;\n        var lineDash = state.lineDash;\n        var lineDashOffset = state.lineDashOffset;\n        var lineJoin = state.lineJoin;\n        var lineWidth = state.lineWidth;\n        var miterLimit = state.miterLimit;\n        if (state.currentStrokeStyle != strokeStyle ||\n            state.currentLineCap != lineCap ||\n            (lineDash != state.currentLineDash &&\n                !equals(state.currentLineDash, lineDash)) ||\n            state.currentLineDashOffset != lineDashOffset ||\n            state.currentLineJoin != lineJoin ||\n            state.currentLineWidth != lineWidth ||\n            state.currentMiterLimit != miterLimit) {\n            if (strokeStyle !== undefined) {\n                applyStroke.call(this, state);\n            }\n            state.currentStrokeStyle = strokeStyle;\n            state.currentLineCap = lineCap;\n            state.currentLineDash = lineDash;\n            state.currentLineDashOffset = lineDashOffset;\n            state.currentLineJoin = lineJoin;\n            state.currentLineWidth = lineWidth;\n            state.currentMiterLimit = miterLimit;\n        }\n    };\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.endGeometry = function (feature) {\n        this.beginGeometryInstruction1_[2] = this.instructions.length;\n        this.beginGeometryInstruction1_ = null;\n        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n        this.beginGeometryInstruction2_ = null;\n        var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n        this.instructions.push(endGeometryInstruction);\n        this.hitDetectionInstructions.push(endGeometryInstruction);\n    };\n    /**\n     * Get the buffered rendering extent.  Rendering will be clipped to the extent\n     * provided to the constructor.  To account for symbolizers that may intersect\n     * this extent, we calculate a buffered extent (e.g. based on stroke width).\n     * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n     * @protected\n     */\n    CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n        if (!this.bufferedMaxExtent_) {\n            this.bufferedMaxExtent_ = clone(this.maxExtent);\n            if (this.maxLineWidth > 0) {\n                var width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n                buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n            }\n        }\n        return this.bufferedMaxExtent_;\n    };\n    return CanvasBuilder;\n}(VectorContext));\nexport default CanvasBuilder;\n//# sourceMappingURL=Builder.js.map"]},"metadata":{},"sourceType":"module"}