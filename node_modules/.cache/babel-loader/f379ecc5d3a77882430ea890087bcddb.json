{"ast":null,"code":"/**\n * @module ol/render/canvas/ExecutorGroup\n */\nimport Executor from './Executor.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nvar ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\nvar ExecutorGroup = /** @class */function () {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [opt_renderBuffer] Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n    this.createExecutors_(allInstructions);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  ExecutorGroup.prototype.clip = function (context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n    for (var zIndex in allInstructions) {\n      var executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      var instructionByZindex = allInstructions[zIndex];\n      for (var builderType in instructionByZindex) {\n        var instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n      }\n    }\n  };\n  /**\n   * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  ExecutorGroup.prototype.hasExecutors = function (executors) {\n    for (var zIndex in this.executorsByZIndex_) {\n      var candidates = this.executorsByZIndex_[zIndex];\n      for (var i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var newContext = !this.hitDetectionContext_;\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);\n    }\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var indexes = getPixelIndexArray(hitTolerance);\n    var builderType;\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function featureCallback(feature, geometry) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {\n        if (imageData[indexes[i_1]] > 0) {\n          if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.indexOf(feature) !== -1) {\n            var idx = (indexes[i_1] - 3) / 4;\n            var x = hitTolerance - idx % contextSize;\n            var y = hitTolerance - (idx / contextSize | 0);\n            var result_1 = callback(feature, geometry, x * x + y * y);\n            if (result_1) {\n              return result_1;\n            }\n          }\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n      return undefined;\n    }\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>|null} Clip coordinates.\n   */\n  ExecutorGroup.prototype.getClipCoords = function (transform) {\n    var maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n  ExecutorGroup.prototype.isEmpty = function () {\n    return isEmpty(this.executorsByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"../canvas.js\").BuilderType>} [opt_builderTypes] Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   */\n  ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n    if (opt_declutterTree) {\n      zs.reverse();\n    }\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        var builderType = builderTypes[j];\n        replay = replays[builderType];\n        if (replay !== undefined) {\n          replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);\n        }\n      }\n    }\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  };\n  return ExecutorGroup;\n}();\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nvar circlePixelIndexArrayCache = {};\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n  var size = radius * 2 + 1;\n  var maxDistanceSq = radius * radius;\n  var distances = new Array(maxDistanceSq + 1);\n  for (var i = 0; i <= radius; ++i) {\n    for (var j = 0; j <= radius; ++j) {\n      var distanceSq = i * i + j * j;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      var distance = distances[distanceSq];\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n  var pixelIndex = [];\n  for (var i = 0, ii = distances.length; i < ii; ++i) {\n    if (distances[i]) {\n      pixelIndex.push.apply(pixelIndex, distances[i]);\n    }\n  }\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nexport default ExecutorGroup;","map":{"version":3,"sources":["../../src/render/canvas/ExecutorGroup.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/render/canvas/ExecutorGroup\n */\nimport Executor from './Executor.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nvar ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\nvar ExecutorGroup = /** @class */ (function () {\n    /**\n     * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n     * should be set here, unless the target context does not exceed that extent (which\n     * can be the case when rendering to tiles).\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {boolean} overlaps The executor group can have overlapping geometries.\n     * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n     * The serializable instructions.\n     * @param {number} [opt_renderBuffer] Optional rendering buffer.\n     */\n    function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        this.maxExtent_ = maxExtent;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.overlaps_ = overlaps;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.resolution_ = resolution;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.renderBuffer_ = opt_renderBuffer;\n        /**\n         * @private\n         * @type {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"./Executor\").default>>}\n         */\n        this.executorsByZIndex_ = {};\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        this.hitDetectionContext_ = null;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        this.hitDetectionTransform_ = createTransform();\n        this.createExecutors_(allInstructions);\n    }\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     */\n    ExecutorGroup.prototype.clip = function (context, transform) {\n        var flatClipCoords = this.getClipCoords(transform);\n        context.beginPath();\n        context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n        context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n        context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n        context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n        context.clip();\n    };\n    /**\n     * Create executors and populate them using the provided instructions.\n     * @private\n     * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n     */\n    ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n        for (var zIndex in allInstructions) {\n            var executors = this.executorsByZIndex_[zIndex];\n            if (executors === undefined) {\n                executors = {};\n                this.executorsByZIndex_[zIndex] = executors;\n            }\n            var instructionByZindex = allInstructions[zIndex];\n            for (var builderType in instructionByZindex) {\n                var instructions = instructionByZindex[builderType];\n                executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n            }\n        }\n    };\n    /**\n     * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n     * @return {boolean} Has executors of the provided types.\n     */\n    ExecutorGroup.prototype.hasExecutors = function (executors) {\n        for (var zIndex in this.executorsByZIndex_) {\n            var candidates = this.executorsByZIndex_[zIndex];\n            for (var i = 0, ii = executors.length; i < ii; ++i) {\n                if (executors[i] in candidates) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {number} rotation Rotation.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n     * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n        hitTolerance = Math.round(hitTolerance);\n        var contextSize = hitTolerance * 2 + 1;\n        var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n        var newContext = !this.hitDetectionContext_;\n        if (newContext) {\n            this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);\n        }\n        var context = this.hitDetectionContext_;\n        if (context.canvas.width !== contextSize ||\n            context.canvas.height !== contextSize) {\n            context.canvas.width = contextSize;\n            context.canvas.height = contextSize;\n        }\n        else if (!newContext) {\n            context.clearRect(0, 0, contextSize, contextSize);\n        }\n        /**\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        var hitExtent;\n        if (this.renderBuffer_ !== undefined) {\n            hitExtent = createEmpty();\n            extendCoordinate(hitExtent, coordinate);\n            buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n        }\n        var indexes = getPixelIndexArray(hitTolerance);\n        var builderType;\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n         * @return {T|undefined} Callback result.\n         */\n        function featureCallback(feature, geometry) {\n            var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n            for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {\n                if (imageData[indexes[i_1]] > 0) {\n                    if (!declutteredFeatures ||\n                        (builderType !== 'Image' && builderType !== 'Text') ||\n                        declutteredFeatures.indexOf(feature) !== -1) {\n                        var idx = (indexes[i_1] - 3) / 4;\n                        var x = hitTolerance - (idx % contextSize);\n                        var y = hitTolerance - ((idx / contextSize) | 0);\n                        var result_1 = callback(feature, geometry, x * x + y * y);\n                        if (result_1) {\n                            return result_1;\n                        }\n                    }\n                    context.clearRect(0, 0, contextSize, contextSize);\n                    break;\n                }\n            }\n            return undefined;\n        }\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.executorsByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var i, j, executors, executor, result;\n        for (i = zs.length - 1; i >= 0; --i) {\n            var zIndexKey = zs[i].toString();\n            executors = this.executorsByZIndex_[zIndexKey];\n            for (j = ORDER.length - 1; j >= 0; --j) {\n                builderType = ORDER[j];\n                executor = executors[builderType];\n                if (executor !== undefined) {\n                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n    /**\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @return {Array<number>|null} Clip coordinates.\n     */\n    ExecutorGroup.prototype.getClipCoords = function (transform) {\n        var maxExtent = this.maxExtent_;\n        if (!maxExtent) {\n            return null;\n        }\n        var minX = maxExtent[0];\n        var minY = maxExtent[1];\n        var maxX = maxExtent[2];\n        var maxY = maxExtent[3];\n        var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n        transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n        return flatClipCoords;\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n    ExecutorGroup.prototype.isEmpty = function () {\n        return isEmpty(this.executorsByZIndex_);\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n     * @param {Array<import(\"../canvas.js\").BuilderType>} [opt_builderTypes] Ordered replay types to replay.\n     *     Default is {@link module:ol/render/replay~ORDER}\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     */\n    ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.executorsByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        // setup clipping so that the parts of over-simplified geometries are not\n        // visible outside the current extent when panning\n        if (this.maxExtent_) {\n            context.save();\n            this.clip(context, transform);\n        }\n        var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n        var i, ii, j, jj, replays, replay;\n        if (opt_declutterTree) {\n            zs.reverse();\n        }\n        for (i = 0, ii = zs.length; i < ii; ++i) {\n            var zIndexKey = zs[i].toString();\n            replays = this.executorsByZIndex_[zIndexKey];\n            for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n                var builderType = builderTypes[j];\n                replay = replays[builderType];\n                if (replay !== undefined) {\n                    replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);\n                }\n            }\n        }\n        if (this.maxExtent_) {\n            context.restore();\n        }\n    };\n    return ExecutorGroup;\n}());\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nvar circlePixelIndexArrayCache = {};\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n    if (circlePixelIndexArrayCache[radius] !== undefined) {\n        return circlePixelIndexArrayCache[radius];\n    }\n    var size = radius * 2 + 1;\n    var maxDistanceSq = radius * radius;\n    var distances = new Array(maxDistanceSq + 1);\n    for (var i = 0; i <= radius; ++i) {\n        for (var j = 0; j <= radius; ++j) {\n            var distanceSq = i * i + j * j;\n            if (distanceSq > maxDistanceSq) {\n                break;\n            }\n            var distance = distances[distanceSq];\n            if (!distance) {\n                distance = [];\n                distances[distanceSq] = distance;\n            }\n            distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n            if (i > 0) {\n                distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n            }\n            if (j > 0) {\n                distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n                if (i > 0) {\n                    distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n                }\n            }\n        }\n    }\n    var pixelIndex = [];\n    for (var i = 0, ii = distances.length; i < ii; ++i) {\n        if (distances[i]) {\n            pixelIndex.push.apply(pixelIndex, distances[i]);\n        }\n    }\n    circlePixelIndexArrayCache[radius] = pixelIndex;\n    return pixelIndex;\n}\nexport default ExecutorGroup;\n//# sourceMappingURL=ExecutorGroup.js.map"]},"metadata":{},"sourceType":"module"}