{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/DragPan\n */\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { all, focusWithTabindex, noModifierKeys, primaryAction } from '../events/condition.js';\nimport { easeOut } from '../easing.js';\nimport { rotate as rotateCoordinate, scale as scaleCoordinate } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nvar DragPan = /** @class */function (_super) {\n  __extends(DragPan, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  function DragPan(opt_options) {\n    var _this = _super.call(this, {\n      stopDown: FALSE\n    }) || this;\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {import(\"../Kinetic.js\").default|undefined}\n     */\n    _this.kinetic_ = options.kinetic;\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    _this.lastCentroid = null;\n    /**\n     * @type {number}\n     */\n    _this.lastPointersCount_;\n    /**\n     * @type {boolean}\n     */\n    _this.panning_ = false;\n    var condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.noKinetic_ = false;\n    return _this;\n  }\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {\n    if (!this.panning_) {\n      this.panning_ = true;\n      this.getMap().getView().beginInteraction();\n    }\n    var targetPointers = this.targetPointers;\n    var centroid = centroidFromPointers(targetPointers);\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        scaleCoordinate(delta, view.getResolution());\n        rotateCoordinate(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        var distance = this.kinetic_.getDistance();\n        var angle = this.kinetic_.getAngle();\n        var center = view.getCenterInternal();\n        var centerpx = map.getPixelFromCoordinateInternal(center);\n        var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    } else {\n      if (this.kinetic_) {\n        // reset so we don't overestimate the kinetic energy after\n        // after one finger up, tiny drag, second finger up\n        this.kinetic_.begin();\n      }\n      this.lastCentroid = null;\n      return true;\n    }\n  };\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      this.lastCentroid = null;\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return DragPan;\n}(PointerInteraction);\nexport default DragPan;","map":{"version":3,"sources":["../src/interaction/DragPan.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/DragPan\n */\nimport PointerInteraction, { centroid as centroidFromPointers, } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { all, focusWithTabindex, noModifierKeys, primaryAction, } from '../events/condition.js';\nimport { easeOut } from '../easing.js';\nimport { rotate as rotateCoordinate, scale as scaleCoordinate, } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nvar DragPan = /** @class */ (function (_super) {\n    __extends(DragPan, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function DragPan(opt_options) {\n        var _this = _super.call(this, {\n            stopDown: FALSE,\n        }) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {import(\"../Kinetic.js\").default|undefined}\n         */\n        _this.kinetic_ = options.kinetic;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         */\n        _this.lastCentroid = null;\n        /**\n         * @type {number}\n         */\n        _this.lastPointersCount_;\n        /**\n         * @type {boolean}\n         */\n        _this.panning_ = false;\n        var condition = options.condition\n            ? options.condition\n            : all(noModifierKeys, primaryAction);\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.condition_ = options.onFocusOnly\n            ? all(focusWithTabindex, condition)\n            : condition;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.noKinetic_ = false;\n        return _this;\n    }\n    /**\n     * Handle pointer drag events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     */\n    DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {\n        if (!this.panning_) {\n            this.panning_ = true;\n            this.getMap().getView().beginInteraction();\n        }\n        var targetPointers = this.targetPointers;\n        var centroid = centroidFromPointers(targetPointers);\n        if (targetPointers.length == this.lastPointersCount_) {\n            if (this.kinetic_) {\n                this.kinetic_.update(centroid[0], centroid[1]);\n            }\n            if (this.lastCentroid) {\n                var delta = [\n                    this.lastCentroid[0] - centroid[0],\n                    centroid[1] - this.lastCentroid[1],\n                ];\n                var map = mapBrowserEvent.map;\n                var view = map.getView();\n                scaleCoordinate(delta, view.getResolution());\n                rotateCoordinate(delta, view.getRotation());\n                view.adjustCenterInternal(delta);\n            }\n        }\n        else if (this.kinetic_) {\n            // reset so we don't overestimate the kinetic energy after\n            // after one finger down, tiny drag, second finger down\n            this.kinetic_.begin();\n        }\n        this.lastCentroid = centroid;\n        this.lastPointersCount_ = targetPointers.length;\n        mapBrowserEvent.originalEvent.preventDefault();\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} If the event was consumed.\n     */\n    DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        if (this.targetPointers.length === 0) {\n            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n                var distance = this.kinetic_.getDistance();\n                var angle = this.kinetic_.getAngle();\n                var center = view.getCenterInternal();\n                var centerpx = map.getPixelFromCoordinateInternal(center);\n                var dest = map.getCoordinateFromPixelInternal([\n                    centerpx[0] - distance * Math.cos(angle),\n                    centerpx[1] - distance * Math.sin(angle),\n                ]);\n                view.animateInternal({\n                    center: view.getConstrainedCenter(dest),\n                    duration: 500,\n                    easing: easeOut,\n                });\n            }\n            if (this.panning_) {\n                this.panning_ = false;\n                view.endInteraction();\n            }\n            return false;\n        }\n        else {\n            if (this.kinetic_) {\n                // reset so we don't overestimate the kinetic energy after\n                // after one finger up, tiny drag, second finger up\n                this.kinetic_.begin();\n            }\n            this.lastCentroid = null;\n            return true;\n        }\n    };\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} If the event was consumed.\n     */\n    DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {\n        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n            var map = mapBrowserEvent.map;\n            var view = map.getView();\n            this.lastCentroid = null;\n            // stop any current animation\n            if (view.getAnimating()) {\n                view.cancelAnimations();\n            }\n            if (this.kinetic_) {\n                this.kinetic_.begin();\n            }\n            // No kinetic as soon as more than one pointer on the screen is\n            // detected. This is to prevent nasty pans after pinch.\n            this.noKinetic_ = this.targetPointers.length > 1;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return DragPan;\n}(PointerInteraction));\nexport default DragPan;\n//# sourceMappingURL=DragPan.js.map"]},"metadata":{},"sourceType":"module"}