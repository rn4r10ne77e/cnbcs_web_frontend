{"ast":null,"code":"import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [opt_width] Canvas width.\n * @param {number} [opt_height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  var canvas;\n  if (opt_canvasPool && opt_canvasPool.length) {\n    canvas = opt_canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n  if (opt_height) {\n    canvas.height = opt_height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {CanvasRenderingContext2D} */canvas.getContext('2d', opt_Context2DSettings);\n}\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n  var canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n  return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n  var height = element.offsetHeight;\n  var style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n  return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n  var oldChildren = node.childNodes;\n  for (var i = 0; true; ++i) {\n    var oldChild = oldChildren[i];\n    var newChild = children[i];\n    // check if our work is done\n    if (!oldChild && !newChild) {\n      break;\n    }\n    // check if children match\n    if (oldChild === newChild) {\n      continue;\n    }\n    // check if a new child needs to be added\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    }\n    // check if an old child needs to be removed\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    }\n    // reorder\n    node.insertBefore(newChild, oldChild);\n  }\n}","map":{"version":3,"sources":["src/dom.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [opt_width] Canvas width.\n * @param {number} [opt_height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {\n    /** @type {HTMLCanvasElement|OffscreenCanvas} */\n    var canvas;\n    if (opt_canvasPool && opt_canvasPool.length) {\n        canvas = opt_canvasPool.shift();\n    }\n    else if (WORKER_OFFSCREEN_CANVAS) {\n        canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n    }\n    else {\n        canvas = document.createElement('canvas');\n    }\n    if (opt_width) {\n        canvas.width = opt_width;\n    }\n    if (opt_height) {\n        canvas.height = opt_height;\n    }\n    //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n    return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d', opt_Context2DSettings));\n}\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n    var canvas = context.canvas;\n    canvas.width = 1;\n    canvas.height = 1;\n    context.clearRect(0, 0, 1, 1);\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n    var width = element.offsetWidth;\n    var style = getComputedStyle(element);\n    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n    return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n    var height = element.offsetHeight;\n    var style = getComputedStyle(element);\n    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n    return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n    var parent = oldNode.parentNode;\n    if (parent) {\n        parent.replaceChild(newNode, oldNode);\n    }\n}\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n    return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n    while (node.lastChild) {\n        node.removeChild(node.lastChild);\n    }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n    var oldChildren = node.childNodes;\n    for (var i = 0; true; ++i) {\n        var oldChild = oldChildren[i];\n        var newChild = children[i];\n        // check if our work is done\n        if (!oldChild && !newChild) {\n            break;\n        }\n        // check if children match\n        if (oldChild === newChild) {\n            continue;\n        }\n        // check if a new child needs to be added\n        if (!oldChild) {\n            node.appendChild(newChild);\n            continue;\n        }\n        // check if an old child needs to be removed\n        if (!newChild) {\n            node.removeChild(oldChild);\n            --i;\n            continue;\n        }\n        // reorder\n        node.insertBefore(newChild, oldChild);\n    }\n}\n//# sourceMappingURL=dom.js.map"]},"metadata":{},"sourceType":"module"}