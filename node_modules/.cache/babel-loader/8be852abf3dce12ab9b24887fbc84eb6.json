{"ast":null,"code":"/**\n * @module ol/expr/expression\n */\nimport { ascending } from '../array.js';\nimport { fromString as colorFromString } from '../color.js';\nimport { toSize } from '../size.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * Reading operators:\n *   `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\n *   `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\n *   `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   `['resolution']` returns the current resolution\n *   `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   `['zoom']` The current zoom level (WebGL only).\n *   `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\n *\n * Math operators:\n *   `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   `['/', value1, value2]` divides `value1` by `value2`\n *   `['+', value1, value2, ...]` adds the values\n *   `['-', value1, value2]` subtracts `value2` from `value1`\n *   `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   `['abs', value1]` returns the absolute value of `value1`\n *   `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\n *     `false` otherwise.\n *     Note that for WebGL layers, the hardcoded value `-9999999` is used to distinguish when a property is not defined.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size'\n};\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * @param {number} type The type.\n * @return {boolean} The type is one of the specific types (not any or a union type).\n */\nfunction isSpecific(type) {\n  return type in typeNames;\n}\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    if (!isSpecific(type)) {\n      throw new Error(`literal expressions must have a specific type, got ${typeName(type)}`);\n    }\n    this.type = type;\n    this.value = value;\n  }\n}\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n * @property {boolean} mapState The style uses the map state (view state or time elapsed).\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n    mapState: false\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {number} expectedType The expected type.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, expectedType, context) {\n  switch (typeof encoded) {\n    case 'boolean':\n      {\n        if (isType(expectedType, StringType)) {\n          return new LiteralExpression(StringType, encoded ? 'true' : 'false');\n        }\n        if (!includesType(expectedType, BooleanType)) {\n          throw new Error(`got a boolean, but expected ${typeName(expectedType)}`);\n        }\n        return new LiteralExpression(BooleanType, encoded);\n      }\n    case 'number':\n      {\n        if (isType(expectedType, SizeType)) {\n          return new LiteralExpression(SizeType, toSize(encoded));\n        }\n        if (isType(expectedType, BooleanType)) {\n          return new LiteralExpression(BooleanType, !!encoded);\n        }\n        if (isType(expectedType, StringType)) {\n          return new LiteralExpression(StringType, encoded.toString());\n        }\n        if (!includesType(expectedType, NumberType)) {\n          throw new Error(`got a number, but expected ${typeName(expectedType)}`);\n        }\n        return new LiteralExpression(NumberType, encoded);\n      }\n    case 'string':\n      {\n        if (isType(expectedType, ColorType)) {\n          return new LiteralExpression(ColorType, colorFromString(encoded));\n        }\n        if (isType(expectedType, BooleanType)) {\n          return new LiteralExpression(BooleanType, !!encoded);\n        }\n        if (!includesType(expectedType, StringType)) {\n          throw new Error(`got a string, but expected ${typeName(expectedType)}`);\n        }\n        return new LiteralExpression(StringType, encoded);\n      }\n    default:\n      {\n        // pass\n      }\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error('expression must be an array or a primitive value');\n  }\n  if (encoded.length === 0) {\n    throw new Error('empty expression');\n  }\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, expectedType, context);\n  }\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('expected an array of numbers');\n    }\n  }\n  if (isType(expectedType, SizeType)) {\n    if (encoded.length !== 2) {\n      throw new Error(`expected an array of two values for a size, got ${encoded.length}`);\n    }\n    return new LiteralExpression(SizeType, encoded);\n  }\n  if (isType(expectedType, ColorType)) {\n    if (encoded.length === 3) {\n      return new LiteralExpression(ColorType, [...encoded, 1]);\n    }\n    if (encoded.length === 4) {\n      return new LiteralExpression(ColorType, encoded);\n    }\n    throw new Error(`expected an array of 3 or 4 values for a color, got ${encoded.length}`);\n  }\n  if (!includesType(expectedType, NumberArrayType)) {\n    throw new Error(`got an array of numbers, but expected ${typeName(expectedType)}`);\n  }\n  return new LiteralExpression(NumberArrayType, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  LineMetric: 'line-metric',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string',\n  Has: 'has'\n};\n\n/**\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\n *\n * Second argument is the expected type.\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\n  [Ops.Concat]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(StringType)),\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\n  [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Any]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)),\n  [Ops.All]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)),\n  [Ops.Not]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType)),\n  [Ops.Equal]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)),\n  [Ops.NotEqual]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)),\n  [Ops.GreaterThan]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.LessThan]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Multiply]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType),\n  [Ops.Coalesce]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType),\n  [Ops.Divide]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Add]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(NumberType)),\n  [Ops.Subtract]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Clamp]: createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)),\n  [Ops.Mod]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Pow]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Abs]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Floor]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Ceil]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Round]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Sin]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Cos]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Atan]: createCallExpressionParser(hasArgsCount(1, 2), withArgsOfType(NumberType)),\n  [Ops.Sqrt]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Match]: createCallExpressionParser(hasArgsCount(4, Infinity), hasEvenArgs, withMatchArgs),\n  [Ops.Between]: createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)),\n  [Ops.Interpolate]: createCallExpressionParser(hasArgsCount(6, Infinity), hasEvenArgs, withInterpolateArgs),\n  [Ops.Case]: createCallExpressionParser(hasArgsCount(3, Infinity), hasOddArgs, withCaseArgs),\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\n  [Ops.Number]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)),\n  [Ops.String]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)),\n  [Ops.Array]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(NumberType)),\n  [Ops.Color]: createCallExpressionParser(hasArgsCount(1, 4), withArgsOfType(NumberType)),\n  [Ops.Band]: createCallExpressionParser(hasArgsCount(1, 3), withArgsOfType(NumberType)),\n  [Ops.Palette]: createCallExpressionParser(hasArgsCount(2, 2), withPaletteArgs),\n  [Ops.ToString]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType | NumberType | StringType | ColorType))\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\n *\n * An argument validator applies various checks to an encoded expression arguments and\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\n */\n\n/**\n * @type {ArgValidator}\n */\nfunction withGetArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const args = new Array(argsCount);\n  for (let i = 0; i < argsCount; ++i) {\n    const key = encoded[i + 1];\n    switch (typeof key) {\n      case 'number':\n        {\n          args[i] = new LiteralExpression(NumberType, key);\n          break;\n        }\n      case 'string':\n        {\n          args[i] = new LiteralExpression(StringType, key);\n          break;\n        }\n      default:\n        {\n          throw new Error(`expected a string key or numeric array index for a get operation, got ${key}`);\n        }\n    }\n    if (i === 0) {\n      context.properties.add(String(key));\n    }\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withVarArgs(encoded, returnType, context) {\n  const name = encoded[1];\n  if (typeof name !== 'string') {\n    throw new Error('expected a string argument for var operation');\n  }\n  context.variables.add(name);\n  return [new LiteralExpression(StringType, name)];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesFeatureId(encoded, returnType, context) {\n  context.featureId = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesGeometryType(encoded, returnType, context) {\n  context.geometryType = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesMapState(encoded, returnType, context) {\n  context.mapState = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withNoArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction hasArgsCount(minArgs, maxArgs) {\n  return function (encoded, returnType, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(`expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`);\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;\n      throw new Error(`expected ${range} arguments for ${operation}, got ${argCount}`);\n    }\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withArgsOfReturnType(encoded, returnType, context) {\n  const argCount = encoded.length - 1;\n  /**\n   * @type {Array<Expression>}\n   */\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    const expression = parse(encoded[i + 1], returnType, context);\n    args[i] = expression;\n  }\n  return args;\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsOfType(argType) {\n  return function (encoded, returnType, context) {\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], argType, context);\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasOddArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(`expected an odd number of arguments for ${operation}, got ${argCount} instead`);\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasEvenArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(`expected an even number of arguments for operation ${operation}, got ${argCount} instead`);\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withMatchArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const inputType = StringType | NumberType | BooleanType;\n  const input = parse(encoded[1], inputType, context);\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    try {\n      const match = parse(encoded[i + 2], input.type, context);\n      args[i] = match;\n    } catch (err) {\n      throw new Error(`failed to parse argument ${i + 1} of match expression: ${err.message}`);\n    }\n    try {\n      const output = parse(encoded[i + 3], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(`failed to parse argument ${i + 2} of match expression: ${err.message}`);\n    }\n  }\n  return [input, ...args, fallback];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInterpolateArgs(encoded, returnType, context) {\n  const interpolationType = encoded[1];\n  /**\n   * @type {number}\n   */\n  let base;\n  switch (interpolationType[0]) {\n    case 'linear':\n      base = 1;\n      break;\n    case 'exponential':\n      const b = interpolationType[1];\n      if (typeof b !== 'number' || b <= 0) {\n        throw new Error(`expected a number base for exponential interpolation` + `, got ${JSON.stringify(b)} instead`);\n      }\n      base = b;\n      break;\n    default:\n      throw new Error(`invalid interpolation type: ${JSON.stringify(interpolationType)}`);\n  }\n  const interpolation = new LiteralExpression(NumberType, base);\n  let input;\n  try {\n    input = parse(encoded[2], NumberType, context);\n  } catch (err) {\n    throw new Error(`failed to parse argument 1 in interpolate expression: ${err.message}`);\n  }\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    try {\n      const stop = parse(encoded[i + 3], NumberType, context);\n      args[i] = stop;\n    } catch (err) {\n      throw new Error(`failed to parse argument ${i + 2} for interpolate expression: ${err.message}`);\n    }\n    try {\n      const output = parse(encoded[i + 4], returnType, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(`failed to parse argument ${i + 3} for interpolate expression: ${err.message}`);\n    }\n  }\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withCaseArgs(encoded, returnType, context) {\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    try {\n      const condition = parse(encoded[i + 1], BooleanType, context);\n      args[i] = condition;\n    } catch (err) {\n      throw new Error(`failed to parse argument ${i} of case expression: ${err.message}`);\n    }\n    try {\n      const output = parse(encoded[i + 2], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(`failed to parse argument ${i + 1} of case expression: ${err.message}`);\n    }\n  }\n  args[args.length - 1] = fallback;\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInArgs(encoded, returnType, context) {\n  let haystack = encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(`the second argument for the \"in\" operator must be an array`);\n  }\n  /**\n   * @type {number}\n   */\n  let needleType;\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(`for the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions`);\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(`failed to parse \"in\" expression: the literal operator must be followed by an array`);\n    }\n    haystack = haystack[1];\n    needleType = StringType;\n  } else {\n    needleType = NumberType;\n  }\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    try {\n      const arg = parse(haystack[i], needleType, context);\n      args[i] = arg;\n    } catch (err) {\n      throw new Error(`failed to parse haystack item ${i} for \"in\" expression: ${err.message}`);\n    }\n  }\n  const needle = parse(encoded[1], needleType, context);\n  return [needle, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withPaletteArgs(encoded, returnType, context) {\n  let index;\n  try {\n    index = parse(encoded[1], NumberType, context);\n  } catch (err) {\n    throw new Error(`failed to parse first argument in palette expression: ${err.message}`);\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('the second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    let color;\n    try {\n      color = parse(colors[i], ColorType, context);\n    } catch (err) {\n      throw new Error(`failed to parse color at index ${i} in palette expression: ${err.message}`);\n    }\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(`the palette color at index ${i} must be a literal value`);\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\n * to return the parsed arguments.\n * @return {Parser} The parser.\n */\nfunction createCallExpressionParser(...validators) {\n  return function (encoded, returnType, context) {\n    const operator = encoded[0];\n\n    /**\n     * @type {Array<Expression>}\n     */\n    let args;\n    for (let i = 0; i < validators.length; i++) {\n      const parsed = validators[i](encoded, returnType, context);\n      if (i == validators.length - 1) {\n        if (!parsed) {\n          throw new Error('expected last argument validator to return the parsed args');\n        }\n        args = parsed;\n      }\n    }\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {number} returnType The expected return type of the call expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, returnType, context) {\n  const operator = encoded[0];\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`unknown operator: ${operator}`);\n  }\n  return parser(encoded, returnType, context);\n}\n\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n  const type = geometry.getType();\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return /** @type {'Point'|'LineString'|'Polygon'} */type.substring(5);\n    case 'Circle':\n      return 'Polygon';\n    case 'GeometryCollection':\n      return computeGeometryType(/** @type {import(\"../geom/GeometryCollection.js\").default} */geometry.getGeometries()[0]);\n    default:\n      return '';\n  }\n}","map":{"version":3,"names":["ascending","fromString","colorFromString","toSize","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","SizeType","AnyType","Math","pow","typeNames","namedTypes","Object","keys","map","Number","sort","isSpecific","type","typeName","names","namedType","includesType","push","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","constructor","value","Error","CallExpression","operator","args","newParsingContext","variables","Set","properties","featureId","geometryType","mapState","parse","encoded","expectedType","context","toString","Array","isArray","parseCallExpression","item","Ops","Get","Var","Concat","GeometryType","LineMetric","Any","All","Not","Resolution","Zoom","Time","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","Between","Interpolate","Coalesce","Case","In","String","Color","Id","Band","Palette","ToString","Has","parsers","createCallExpressionParser","hasArgsCount","Infinity","withGetArgs","withVarArgs","usesFeatureId","withNoArgs","withArgsOfType","usesGeometryType","usesMapState","withArgsOfReturnType","hasEvenArgs","withMatchArgs","withInterpolateArgs","hasOddArgs","withCaseArgs","withInArgs","withPaletteArgs","returnType","argsCount","i","key","add","name","operation","minArgs","maxArgs","argCount","plural","range","expression","argType","inputType","input","fallback","match","err","message","output","interpolationType","base","b","JSON","stringify","interpolation","stop","condition","haystack","needleType","arg","needle","index","colors","parsedColors","color","validators","parsed","parser","computeGeometryType","geometry","getType","substring","getGeometries"],"sources":["C:/prj/cnbcs_web_frontend/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {fromString as colorFromString} from '../color.js';\nimport {toSize} from '../size.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * Reading operators:\n *   `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\n *   `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\n *   `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   `['resolution']` returns the current resolution\n *   `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   `['zoom']` The current zoom level (WebGL only).\n *   `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\n *\n * Math operators:\n *   `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   `['/', value1, value2]` divides `value1` by `value2`\n *   `['+', value1, value2, ...]` adds the values\n *   `['-', value1, value2]` subtracts `value2` from `value1`\n *   `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   `['abs', value1]` returns the absolute value of `value1`\n *   `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\n *     `false` otherwise.\n *     Note that for WebGL layers, the hardcoded value `-9999999` is used to distinguish when a property is not defined.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * @param {number} type The type.\n * @return {boolean} The type is one of the specific types (not any or a union type).\n */\nfunction isSpecific(type) {\n  return type in typeNames;\n}\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    if (!isSpecific(type)) {\n      throw new Error(\n        `literal expressions must have a specific type, got ${typeName(type)}`,\n      );\n    }\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n * @property {boolean} mapState The style uses the map state (view state or time elapsed).\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n    mapState: false,\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {number} expectedType The expected type.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, expectedType, context) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      if (isType(expectedType, StringType)) {\n        return new LiteralExpression(StringType, encoded ? 'true' : 'false');\n      }\n      if (!includesType(expectedType, BooleanType)) {\n        throw new Error(\n          `got a boolean, but expected ${typeName(expectedType)}`,\n        );\n      }\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      if (isType(expectedType, SizeType)) {\n        return new LiteralExpression(SizeType, toSize(encoded));\n      }\n      if (isType(expectedType, BooleanType)) {\n        return new LiteralExpression(BooleanType, !!encoded);\n      }\n      if (isType(expectedType, StringType)) {\n        return new LiteralExpression(StringType, encoded.toString());\n      }\n      if (!includesType(expectedType, NumberType)) {\n        throw new Error(`got a number, but expected ${typeName(expectedType)}`);\n      }\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      if (isType(expectedType, ColorType)) {\n        return new LiteralExpression(ColorType, colorFromString(encoded));\n      }\n      if (isType(expectedType, BooleanType)) {\n        return new LiteralExpression(BooleanType, !!encoded);\n      }\n      if (!includesType(expectedType, StringType)) {\n        throw new Error(`got a string, but expected ${typeName(expectedType)}`);\n      }\n      return new LiteralExpression(StringType, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, expectedType, context);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('expected an array of numbers');\n    }\n  }\n\n  if (isType(expectedType, SizeType)) {\n    if (encoded.length !== 2) {\n      throw new Error(\n        `expected an array of two values for a size, got ${encoded.length}`,\n      );\n    }\n    return new LiteralExpression(SizeType, encoded);\n  }\n\n  if (isType(expectedType, ColorType)) {\n    if (encoded.length === 3) {\n      return new LiteralExpression(ColorType, [...encoded, 1]);\n    }\n    if (encoded.length === 4) {\n      return new LiteralExpression(ColorType, encoded);\n    }\n    throw new Error(\n      `expected an array of 3 or 4 values for a color, got ${encoded.length}`,\n    );\n  }\n\n  if (!includesType(expectedType, NumberArrayType)) {\n    throw new Error(\n      `got an array of numbers, but expected ${typeName(expectedType)}`,\n    );\n  }\n\n  return new LiteralExpression(NumberArrayType, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  LineMetric: 'line-metric',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string',\n  Has: 'has',\n};\n\n/**\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\n *\n * Second argument is the expected type.\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\n  [Ops.Concat]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(StringType),\n  ),\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\n  [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Any]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.All]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.Not]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.Equal]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.NotEqual]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.GreaterThan]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.LessThan]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Multiply]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfReturnType,\n  ),\n  [Ops.Coalesce]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfReturnType,\n  ),\n  [Ops.Divide]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Add]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Subtract]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Clamp]: createCallExpressionParser(\n    hasArgsCount(3, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Mod]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Pow]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Abs]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Floor]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Ceil]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Round]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Sin]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Cos]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Atan]: createCallExpressionParser(\n    hasArgsCount(1, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Sqrt]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Match]: createCallExpressionParser(\n    hasArgsCount(4, Infinity),\n    hasEvenArgs,\n    withMatchArgs,\n  ),\n  [Ops.Between]: createCallExpressionParser(\n    hasArgsCount(3, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Interpolate]: createCallExpressionParser(\n    hasArgsCount(6, Infinity),\n    hasEvenArgs,\n    withInterpolateArgs,\n  ),\n  [Ops.Case]: createCallExpressionParser(\n    hasArgsCount(3, Infinity),\n    hasOddArgs,\n    withCaseArgs,\n  ),\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\n  [Ops.Number]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.String]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.Array]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Color]: createCallExpressionParser(\n    hasArgsCount(1, 4),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Band]: createCallExpressionParser(\n    hasArgsCount(1, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Palette]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withPaletteArgs,\n  ),\n  [Ops.ToString]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(BooleanType | NumberType | StringType | ColorType),\n  ),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\n *\n * An argument validator applies various checks to an encoded expression arguments and\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\n */\n\n/**\n * @type {ArgValidator}\n */\nfunction withGetArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const args = new Array(argsCount);\n  for (let i = 0; i < argsCount; ++i) {\n    const key = encoded[i + 1];\n    switch (typeof key) {\n      case 'number': {\n        args[i] = new LiteralExpression(NumberType, key);\n        break;\n      }\n      case 'string': {\n        args[i] = new LiteralExpression(StringType, key);\n        break;\n      }\n      default: {\n        throw new Error(\n          `expected a string key or numeric array index for a get operation, got ${key}`,\n        );\n      }\n    }\n    if (i === 0) {\n      context.properties.add(String(key));\n    }\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withVarArgs(encoded, returnType, context) {\n  const name = encoded[1];\n  if (typeof name !== 'string') {\n    throw new Error('expected a string argument for var operation');\n  }\n  context.variables.add(name);\n\n  return [new LiteralExpression(StringType, name)];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesFeatureId(encoded, returnType, context) {\n  context.featureId = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesGeometryType(encoded, returnType, context) {\n  context.geometryType = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesMapState(encoded, returnType, context) {\n  context.mapState = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withNoArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction hasArgsCount(minArgs, maxArgs) {\n  return function (encoded, returnType, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `expected ${range} arguments for ${operation}, got ${argCount}`,\n      );\n    }\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withArgsOfReturnType(encoded, returnType, context) {\n  const argCount = encoded.length - 1;\n  /**\n   * @type {Array<Expression>}\n   */\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    const expression = parse(encoded[i + 1], returnType, context);\n    args[i] = expression;\n  }\n  return args;\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsOfType(argType) {\n  return function (encoded, returnType, context) {\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], argType, context);\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasOddArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `expected an odd number of arguments for ${operation}, got ${argCount} instead`,\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasEvenArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`,\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withMatchArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n\n  const inputType = StringType | NumberType | BooleanType;\n\n  const input = parse(encoded[1], inputType, context);\n\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    try {\n      const match = parse(encoded[i + 2], input.type, context);\n      args[i] = match;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 1} of match expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 3], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 2} of match expression: ${err.message}`,\n      );\n    }\n  }\n\n  return [input, ...args, fallback];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInterpolateArgs(encoded, returnType, context) {\n  const interpolationType = encoded[1];\n  /**\n   * @type {number}\n   */\n  let base;\n  switch (interpolationType[0]) {\n    case 'linear':\n      base = 1;\n      break;\n    case 'exponential':\n      const b = interpolationType[1];\n      if (typeof b !== 'number' || b <= 0) {\n        throw new Error(\n          `expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(b)} instead`,\n        );\n      }\n      base = b;\n      break;\n    default:\n      throw new Error(\n        `invalid interpolation type: ${JSON.stringify(interpolationType)}`,\n      );\n  }\n\n  const interpolation = new LiteralExpression(NumberType, base);\n\n  let input;\n  try {\n    input = parse(encoded[2], NumberType, context);\n  } catch (err) {\n    throw new Error(\n      `failed to parse argument 1 in interpolate expression: ${err.message}`,\n    );\n  }\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    try {\n      const stop = parse(encoded[i + 3], NumberType, context);\n      args[i] = stop;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 4], returnType, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`,\n      );\n    }\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withCaseArgs(encoded, returnType, context) {\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    try {\n      const condition = parse(encoded[i + 1], BooleanType, context);\n      args[i] = condition;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i} of case expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 2], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 1} of case expression: ${err.message}`,\n      );\n    }\n  }\n\n  args[args.length - 1] = fallback;\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInArgs(encoded, returnType, context) {\n  let haystack = encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `the second argument for the \"in\" operator must be an array`,\n    );\n  }\n  /**\n   * @type {number}\n   */\n  let needleType;\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `for the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions`,\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `failed to parse \"in\" expression: the literal operator must be followed by an array`,\n      );\n    }\n    haystack = haystack[1];\n    needleType = StringType;\n  } else {\n    needleType = NumberType;\n  }\n\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    try {\n      const arg = parse(haystack[i], needleType, context);\n      args[i] = arg;\n    } catch (err) {\n      throw new Error(\n        `failed to parse haystack item ${i} for \"in\" expression: ${err.message}`,\n      );\n    }\n  }\n\n  const needle = parse(encoded[1], needleType, context);\n  return [needle, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withPaletteArgs(encoded, returnType, context) {\n  let index;\n  try {\n    index = parse(encoded[1], NumberType, context);\n  } catch (err) {\n    throw new Error(\n      `failed to parse first argument in palette expression: ${err.message}`,\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('the second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    let color;\n    try {\n      color = parse(colors[i], ColorType, context);\n    } catch (err) {\n      throw new Error(\n        `failed to parse color at index ${i} in palette expression: ${err.message}`,\n      );\n    }\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `the palette color at index ${i} must be a literal value`,\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\n * to return the parsed arguments.\n * @return {Parser} The parser.\n */\nfunction createCallExpressionParser(...validators) {\n  return function (encoded, returnType, context) {\n    const operator = encoded[0];\n\n    /**\n     * @type {Array<Expression>}\n     */\n    let args;\n    for (let i = 0; i < validators.length; i++) {\n      const parsed = validators[i](encoded, returnType, context);\n      if (i == validators.length - 1) {\n        if (!parsed) {\n          throw new Error(\n            'expected last argument validator to return the parsed args',\n          );\n        }\n        args = parsed;\n      }\n    }\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {number} returnType The expected return type of the call expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, returnType, context) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`unknown operator: ${operator}`);\n  }\n  return parser(encoded, returnType, context);\n}\n\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n  const type = geometry.getType();\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\n    case 'Circle':\n      return 'Polygon';\n    case 'GeometryCollection':\n      return computeGeometryType(\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries()[0],\n      );\n    default:\n      return '';\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,SAAS,QAAO,aAAa;AACrC,SAAQC,UAAU,IAAIC,eAAe,QAAO,aAAa;AACzD,SAAQC,MAAM,QAAO,YAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAC;AAChB,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,WAAW,GAAG,CAAC,IAAIF,QAAQ,EAAE;AAC1C,OAAO,MAAMG,UAAU,GAAG,CAAC,IAAIH,QAAQ,EAAE;AACzC,OAAO,MAAMI,UAAU,GAAG,CAAC,IAAIJ,QAAQ,EAAE;AACzC,OAAO,MAAMK,SAAS,GAAG,CAAC,IAAIL,QAAQ,EAAE;AACxC,OAAO,MAAMM,eAAe,GAAG,CAAC,IAAIN,QAAQ,EAAE;AAC9C,OAAO,MAAMO,QAAQ,GAAG,CAAC,IAAIP,QAAQ,EAAE;AACvC,OAAO,MAAMQ,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,QAAQ,CAAC,GAAG,CAAC;AAEhD,MAAMW,SAAS,GAAG;EAChB,C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","ignoreList":[]},"metadata":{},"sourceType":"module"}