{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */function (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\n   * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n   */\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE, {\n      interpolate: !!opt_interpolate\n    }) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n  ReprojTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          var state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  /**\n   * Remove from the cache due to expiry\n   */\n  ReprojTile.prototype.release = function () {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    _super.prototype.release.call(this);\n  };\n  return ReprojTile;\n}(Tile);\nexport default ReprojTile;","map":{"version":3,"sources":["../src/reproj/Tile.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;AAEG;AACH,SAAQ,eAAe,QAAO,aAAa;AAE3C,OAAO,SAAS,MAAM,wBAAwB;AAC9C,OAAO,IAAI,MAAM,YAAY;AAC7B,OAAO,SAAS,MAAM,iBAAiB;AACvC,OAAO,aAAa,MAAM,oBAAoB;AAC9C,SACE,+BAA+B,EAC/B,UAAU,EACV,MAAM,IAAI,iBAAiB,QACtB,cAAc;AACrB,SAAQ,KAAK,QAAO,YAAY;AAChC,SAAQ,OAAO,EAAE,eAAe,QAAO,cAAc;AACrD,SAAQ,MAAM,EAAE,aAAa,QAAO,cAAc;AAClD,SAAQ,aAAa,QAAO,WAAW;AAEvC;;AAEG;AAEH;;;;;AAKG;AACH,IAAA,UAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAyB,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;EACvB;;;;;;;;;;;;;;AAcG;EACH,SAAA,UAAA,CACE,UAAU,EACV,cAAc,EACd,UAAU,EACV,cAAc,EACd,SAAS,EACT,gBAAgB,EAChB,UAAU,EACV,MAAM,EACN,eAAe,EACf,kBAAkB,EAClB,eAAe,EACf,eAAe,EAAA;IAZjB,IAAA,KAAA,GAcE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,SAAS,EAAE,SAAS,CAAC,IAAI,EAAE;MAAC,WAAW,EAAE,CAAC,CAAC;IAAe,CAAC,CAAC,IAAA,IAAA;IAElE;;;AAGG;IACH,KAAI,CAAC,YAAY,GAAG,eAAe,KAAK,SAAS,GAAG,eAAe,GAAG,KAAK;IAE3E;;;AAGG;IACH,KAAI,CAAC,WAAW,GAAG,UAAU;IAE7B;;;AAGG;IACH,KAAI,CAAC,OAAO,GAAG,MAAM;IAErB;;;AAGG;IACH,KAAI,CAAC,OAAO,GAAG,IAAI;IAEnB;;;AAGG;IACH,KAAI,CAAC,eAAe,GAAG,cAAc;IAErC;;;AAGG;IACH,KAAI,CAAC,eAAe,GAAG,cAAc;IAErC;;;AAGG;IACH,KAAI,CAAC,iBAAiB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,SAAS;IAExE;;;AAGG;IACH,KAAI,CAAC,YAAY,GAAG,EAAE;IAEtB;;;AAGG;IACH,KAAI,CAAC,oBAAoB,GAAG,IAAI;IAEhC;;;AAGG;IACH,KAAI,CAAC,QAAQ,GAAG,CAAC;IAEjB,IAAM,YAAY,GAAG,cAAc,CAAC,kBAAkB,CACpD,KAAI,CAAC,iBAAiB,CACvB;IACD,IAAM,eAAe,GAAG,KAAI,CAAC,eAAe,CAAC,SAAS,CAAA,CAAE;IACxD,IAAI,eAAe,GAAG,KAAI,CAAC,eAAe,CAAC,SAAS,CAAA,CAAE;IAEtD,IAAM,mBAAmB,GAAG,eAAe,GACvC,eAAe,CAAC,YAAY,EAAE,eAAe,CAAC,GAC9C,YAAY;IAEhB,IAAI,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE;MACtC;MACA;MACA,KAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK;;IAE7B;IAED,IAAM,gBAAgB,GAAG,UAAU,CAAC,SAAS,CAAA,CAAE;IAC/C,IAAI,gBAAgB,EAAE;MACpB,IAAI,CAAC,eAAe,EAAE;QACpB,eAAe,GAAG,gBAAgB;OACnC,MAAM;QACL,eAAe,GAAG,eAAe,CAAC,eAAe,EAAE,gBAAgB,CAAC;MACrE;IACF;IAED,IAAM,gBAAgB,GAAG,cAAc,CAAC,aAAa,CACnD,KAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAC1B;IAED,IAAM,gBAAgB,GAAG,+BAA+B,CACtD,UAAU,EACV,UAAU,EACV,mBAAmB,EACnB,gBAAgB,CACjB;IAED,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,gBAAgB,IAAI,CAAC,EAAE;MACxD;MACA;MACA,KAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK;;IAE7B;IAED,IAAM,sBAAsB,GAC1B,kBAAkB,KAAK,SAAS,GAAG,kBAAkB,GAAG,eAAe;IAEzE;;;AAGG;IACH,KAAI,CAAC,cAAc,GAAG,IAAI,aAAa,CACrC,UAAU,EACV,UAAU,EACV,mBAAmB,EACnB,eAAe,EACf,gBAAgB,GAAG,sBAAsB,EACzC,gBAAgB,CACjB;IAED,IAAI,KAAI,CAAC,cAAc,CAAC,YAAY,CAAA,CAAE,CAAC,MAAM,KAAK,CAAC,EAAE;MACnD;MACA,KAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK;;IAE7B;IAED,KAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,iBAAiB,CAAC,gBAAgB,CAAC;IAClE,IAAI,YAAY,GAAG,KAAI,CAAC,cAAc,CAAC,qBAAqB,CAAA,CAAE;IAE9D,IAAI,eAAe,EAAE;MACnB,IAAI,UAAU,CAAC,QAAQ,CAAA,CAAE,EAAE;QACzB,YAAY,CAAC,CAAC,CAAC,GAAG,KAAK,CACrB,YAAY,CAAC,CAAC,CAAC,EACf,eAAe,CAAC,CAAC,CAAC,EAClB,eAAe,CAAC,CAAC,CAAC,CACnB;QACD,YAAY,CAAC,CAAC,CAAC,GAAG,KAAK,CACrB,YAAY,CAAC,CAAC,CAAC,EACf,eAAe,CAAC,CAAC,CAAC,EAClB,eAAe,CAAC,CAAC,CAAC,CACnB;OACF,MAAM;QACL,YAAY,GAAG,eAAe,CAAC,YAAY,EAAE,eAAe,CAAC;MAC9D;IACF;IAED,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;MAC1B,KAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK;KAC7B,MAAM;MACL,IAAM,WAAW,GAAG,cAAc,CAAC,yBAAyB,CAC1D,YAAY,EACZ,KAAI,CAAC,QAAQ,CACd;MAED,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,IAAI,WAAW,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;QAClE,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,IAAI,WAAW,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;UAClE,IAAM,IAAI,GAAG,eAAe,CAAC,KAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,CAAC;UACnE,IAAI,IAAI,EAAE;YACR,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;UAC7B;QACF;MACF;MAED,IAAI,KAAI,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;QAClC,KAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK;MAC7B;IACF;;EACH;EAEA;;;AAGG;EACH,UAAA,CAAA,SAAA,CAAA,QAAQ,GAAR,YAAA;IACE,OAAO,IAAI,CAAC,OAAO;EACrB,CAAC;EAED;;AAEG;EACH,UAAA,CAAA,SAAA,CAAA,UAAU,GAAV,YAAA;IACE,IAAM,OAAO,GAAG,EAAE;IAClB,IAAI,CAAC,YAAY,CAAC,OAAO,CACvB,UAAU,IAAI,EAAE,CAAC,EAAE,GAAG,EAAA;MACpB,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAA,CAAE,IAAI,SAAS,CAAC,MAAM,EAAE;QAC/C,OAAO,CAAC,IAAI,CAAC;UACX,MAAM,EAAE,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC;UAC/D,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAA;SACrB,CAAC;MACH;IACH,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CACb;IACD,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;IAE5B,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;MACxB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK;KAC7B,MAAM;MACL,IAAM,CAAC,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC;MACnC,IAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,CAAC;MAChD,IAAM,KAAK,GAAG,OAAO,IAAI,KAAK,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC;MACvD,IAAM,MAAM,GAAG,OAAO,IAAI,KAAK,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC;MACxD,IAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC;MAC9D,IAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,aAAa,CACzD,IAAI,CAAC,QAAQ,CACd;MAED,IAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAC1D,IAAI,CAAC,iBAAiB,CACvB;MAED,IAAI,CAAC,OAAO,GAAG,iBAAiB,CAC9B,KAAK,EACL,MAAM,EACN,IAAI,CAAC,WAAW,EAChB,gBAAgB,EAChB,IAAI,CAAC,eAAe,CAAC,SAAS,CAAA,CAAE,EAChC,gBAAgB,EAChB,YAAY,EACZ,IAAI,CAAC,cAAc,EACnB,OAAO,EACP,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,WAAW,CACjB;MAED,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM;IAC9B;IACD,IAAI,CAAC,OAAO,CAAA,CAAE;EAChB,CAAC;EAED;;AAEG;EACH,UAAA,CAAA,SAAA,CAAA,IAAI,GAAJ,YAAA;IACE,IAAI,IAAI,CAAC,KAAK,IAAI,SAAS,CAAC,IAAI,EAAE;MAChC,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,OAAO;MAC9B,IAAI,CAAC,OAAO,CAAA,CAAE;MAEd,IAAI,YAAU,GAAG,CAAC;MAElB,IAAI,CAAC,oBAAoB,GAAG,EAAE;MAC9B,IAAI,CAAC,YAAY,CAAC,OAAO,CACvB,UAAU,IAAI,EAAE,CAAC,EAAE,GAAG,EAAA;QACpB,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAA,CAAE;QAC7B,IAAI,KAAK,IAAI,SAAS,CAAC,IAAI,IAAI,KAAK,IAAI,SAAS,CAAC,OAAO,EAAE;UACzD,YAAU,EAAE;UAEZ,IAAM,iBAAe,GAAG,MAAM,CAC5B,IAAI,EACJ,SAAS,CAAC,MAAM,EAChB,UAAU,CAAC,EAAA;YACT,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAA,CAAE;YAC7B,IACE,KAAK,IAAI,SAAS,CAAC,MAAM,IACzB,KAAK,IAAI,SAAS,CAAC,KAAK,IACxB,KAAK,IAAI,SAAS,CAAC,KAAK,EACxB;cACA,aAAa,CAAC,iBAAe,CAAC;cAC9B,YAAU,EAAE;cACZ,IAAI,YAAU,KAAK,CAAC,EAAE;gBACpB,IAAI,CAAC,gBAAgB,CAAA,CAAE;gBACvB,IAAI,CAAC,UAAU,CAAA,CAAE;cAClB;YACF;UACH,CAAC,EACD,IAAI,CACL;UACD,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,iBAAe,CAAC;QAChD;MACH,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CACb;MAED,IAAI,YAAU,KAAK,CAAC,EAAE;QACpB,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;OAC1C,MAAM;QACL,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,IAAI,EAAE,CAAC,EAAE,GAAG,EAAA;UAC9C,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAA,CAAE;UAC7B,IAAI,KAAK,IAAI,SAAS,CAAC,IAAI,EAAE;YAC3B,IAAI,CAAC,IAAI,CAAA,CAAE;UACZ;QACH,CAAC,CAAC;MACH;IACF;EACH,CAAC;EAED;;AAEG;EACH,UAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,YAAA;IACE,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,aAAa,CAAC;IAChD,IAAI,CAAC,oBAAoB,GAAG,IAAI;EAClC,CAAC;EAED;;AAEG;EACH,UAAA,CAAA,SAAA,CAAA,OAAO,GAAP,YAAA;IACE,IAAI,IAAI,CAAC,OAAO,EAAE;MAChB,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;MAC5C,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;MAC7B,IAAI,CAAC,OAAO,GAAG,IAAI;IACpB;IACD,MAAA,CAAA,SAAA,CAAM,OAAO,CAAA,IAAA,CAAA,IAAA,CAAE;EACjB,CAAC;EACH,OAAA,UAAC;AAAD,CAAC,CAhVwB,IAAI,CAAA;AAkV7B,eAAe,UAAU","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n     * @param {boolean} [opt_renderEdges] Render reprojection edges.\n     * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n            else {\n                this.sourceTiles_.forEach(function (tile, i, arr) {\n                    var state = tile.getState();\n                    if (state == TileState.IDLE) {\n                        tile.load();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    /**\n     * Remove from the cache due to expiry\n     */\n    ReprojTile.prototype.release = function () {\n        if (this.canvas_) {\n            releaseCanvas(this.canvas_.getContext('2d'));\n            canvasPool.push(this.canvas_);\n            this.canvas_ = null;\n        }\n        _super.prototype.release.call(this);\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n//# sourceMappingURL=Tile.js.map"]},"metadata":{},"sourceType":"module"}