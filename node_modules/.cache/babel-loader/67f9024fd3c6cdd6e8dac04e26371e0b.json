{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature;\n  } else if (/** @type {import(\"../Collection.js\").CollectionEvent} */evt.element) {\n    return /** @type {import(\"../Feature.js\").default} */ /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element;\n  }\n}\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nvar Snap = /** @class */function (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  function Snap(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    _this.GEOMETRY_SEGMENTERS_ = {\n      'Point': _this.segmentPointGeometry_.bind(_this),\n      'LineString': _this.segmentLineStringGeometry_.bind(_this),\n      'LinearRing': _this.segmentLineStringGeometry_.bind(_this),\n      'Polygon': _this.segmentPolygonGeometry_.bind(_this),\n      'MultiPoint': _this.segmentMultiPointGeometry_.bind(_this),\n      'MultiLineString': _this.segmentMultiLineStringGeometry_.bind(_this),\n      'MultiPolygon': _this.segmentMultiPolygonGeometry_.bind(_this),\n      'GeometryCollection': _this.segmentGeometryCollectionGeometry_.bind(_this),\n      'Circle': _this.segmentCircleGeometry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        var segments = /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */[];\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          var extents = segments.map(function (s) {\n            return boundingExtent(s);\n          });\n          var segmentsData = segments.map(function (segment) {\n            return {\n              feature: feature,\n              segment: segment\n            };\n          });\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = /** @type {Array<import(\"../Feature.js\").default>} */this.getFeatures_();\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    var segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestVertex;\n    var minSquaredDistance = Infinity;\n    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    var getResult = function () {\n      if (closestVertex) {\n        var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])]\n          };\n        }\n      }\n      return null;\n    };\n    if (this.vertex_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach(function (vertex) {\n            var tempVertexCoord = fromUserCoordinate(vertex, projection);\n            var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      var result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    if (this.edge_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var vertex = null;\n        var segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          var circleGeometry = segmentData.feature.getGeometry();\n          var userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, /** @type {import(\"../geom/Circle.js\").default} */circleGeometry), projection);\n        } else {\n          var _a = segmentData.segment,\n            segmentStart = _a[0],\n            segmentEnd = _a[1];\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          var delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n      var result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentCircleGeometry_ = function (segments, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */circleGeometry.clone().transform(userProjection, projection);\n    }\n    var polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    var coordinates = polygon.getCoordinates()[0];\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentGeometryCollectionGeometry_ = function (segments, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentLineStringGeometry_ = function (segments, geometry) {\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentMultiLineStringGeometry_ = function (segments, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentMultiPointGeometry_ = function (segments, geometry) {\n    geometry.getCoordinates().forEach(function (point) {\n      segments.push([point]);\n    });\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentMultiPolygonGeometry_ = function (segments, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentPointGeometry_ = function (segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentPolygonGeometry_ = function (segments, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  return Snap;\n}(PointerInteraction);\nexport default Snap;","map":{"version":3,"sources":["../src/interaction/Snap.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance, } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate, } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n    if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature) {\n        return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n            .feature;\n    }\n    else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element) {\n        return /** @type {import(\"../Feature.js\").default} */ (\n        /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element);\n    }\n}\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nvar Snap = /** @class */ (function (_super) {\n    __extends(Snap, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Snap(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.handleDownEvent) {\n            pointerOptions.handleDownEvent = TRUE;\n        }\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /**\n         * @type {import(\"../source/Vector.js\").default|null}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.edge_ = options.edge !== undefined ? options.edge : true;\n        /**\n         * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         * @private\n         */\n        _this.featuresListenerKeys_ = [];\n        /**\n         * @type {Object<string, import(\"../events.js\").EventsKey>}\n         * @private\n         */\n        _this.featureChangeListenerKeys_ = {};\n        /**\n         * Extents are preserved so indexed segment can be quickly removed\n         * when its feature geometry changes\n         * @type {Object<string, import(\"../extent.js\").Extent>}\n         * @private\n         */\n        _this.indexedFeaturesExtents_ = {};\n        /**\n         * If a feature geometry changes while a pointer drag|move event occurs, the\n         * feature doesn't get updated right away.  It will be at the next 'pointerup'\n         * event fired.\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         * @private\n         */\n        _this.pendingFeatures_ = {};\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.pixelTolerance_ =\n            options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n        /**\n         * Segment RTree for each layer\n         * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n         * @private\n         */\n        _this.rBush_ = new RBush();\n        /**\n         * @const\n         * @private\n         * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n         */\n        _this.GEOMETRY_SEGMENTERS_ = {\n            'Point': _this.segmentPointGeometry_.bind(_this),\n            'LineString': _this.segmentLineStringGeometry_.bind(_this),\n            'LinearRing': _this.segmentLineStringGeometry_.bind(_this),\n            'Polygon': _this.segmentPolygonGeometry_.bind(_this),\n            'MultiPoint': _this.segmentMultiPointGeometry_.bind(_this),\n            'MultiLineString': _this.segmentMultiLineStringGeometry_.bind(_this),\n            'MultiPolygon': _this.segmentMultiPolygonGeometry_.bind(_this),\n            'GeometryCollection': _this.segmentGeometryCollectionGeometry_.bind(_this),\n            'Circle': _this.segmentCircleGeometry_.bind(_this),\n        };\n        return _this;\n    }\n    /**\n     * Add a feature to the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n     *     Defaults to `true`.\n     * @api\n     */\n    Snap.prototype.addFeature = function (feature, opt_listen) {\n        var register = opt_listen !== undefined ? opt_listen : true;\n        var feature_uid = getUid(feature);\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n            if (segmenter) {\n                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n                var segments = \n                /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n                segmenter(segments, geometry);\n                if (segments.length === 1) {\n                    this.rBush_.insert(boundingExtent(segments[0]), {\n                        feature: feature,\n                        segment: segments[0],\n                    });\n                }\n                else if (segments.length > 1) {\n                    var extents = segments.map(function (s) { return boundingExtent(s); });\n                    var segmentsData = segments.map(function (segment) { return ({\n                        feature: feature,\n                        segment: segment,\n                    }); });\n                    this.rBush_.load(extents, segmentsData);\n                }\n            }\n        }\n        if (register) {\n            this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @private\n     */\n    Snap.prototype.forEachFeatureAdd_ = function (feature) {\n        this.addFeature(feature);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @private\n     */\n    Snap.prototype.forEachFeatureRemove_ = function (feature) {\n        this.removeFeature(feature);\n    };\n    /**\n     * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n     * @private\n     */\n    Snap.prototype.getFeatures_ = function () {\n        var features;\n        if (this.features_) {\n            features = this.features_;\n        }\n        else if (this.source_) {\n            features = this.source_.getFeatures();\n        }\n        return features;\n    };\n    /**\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     */\n    Snap.prototype.handleEvent = function (evt) {\n        var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n        if (result) {\n            evt.coordinate = result.vertex.slice(0, 2);\n            evt.pixel = result.vertexPixel;\n        }\n        return _super.prototype.handleEvent.call(this, evt);\n    };\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureAdd_ = function (evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.addFeature(feature);\n    };\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureRemove_ = function (evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.removeFeature(feature);\n    };\n    /**\n     * @param {import(\"../events/Event.js\").default} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureChange_ = function (evt) {\n        var feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n        if (this.handlingDownUpSequence) {\n            var uid = getUid(feature);\n            if (!(uid in this.pendingFeatures_)) {\n                this.pendingFeatures_[uid] = feature;\n            }\n        }\n        else {\n            this.updateFeature_(feature);\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Snap.prototype.handleUpEvent = function (evt) {\n        var featuresToUpdate = getValues(this.pendingFeatures_);\n        if (featuresToUpdate.length) {\n            featuresToUpdate.forEach(this.updateFeature_.bind(this));\n            this.pendingFeatures_ = {};\n        }\n        return false;\n    };\n    /**\n     * Remove a feature from the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n     *     or not. Defaults to `true`.\n     * @api\n     */\n    Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n        var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n        var feature_uid = getUid(feature);\n        var extent = this.indexedFeaturesExtents_[feature_uid];\n        if (extent) {\n            var rBush = this.rBush_;\n            var nodesToRemove_1 = [];\n            rBush.forEachInExtent(extent, function (node) {\n                if (feature === node.feature) {\n                    nodesToRemove_1.push(node);\n                }\n            });\n            for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n                rBush.remove(nodesToRemove_1[i]);\n            }\n        }\n        if (unregister) {\n            unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n            delete this.featureChangeListenerKeys_[feature_uid];\n        }\n    };\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Snap.prototype.setMap = function (map) {\n        var currentMap = this.getMap();\n        var keys = this.featuresListenerKeys_;\n        var features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n        if (currentMap) {\n            keys.forEach(unlistenByKey);\n            keys.length = 0;\n            features.forEach(this.forEachFeatureRemove_.bind(this));\n        }\n        _super.prototype.setMap.call(this, map);\n        if (map) {\n            if (this.features_) {\n                keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n            }\n            else if (this.source_) {\n                keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n            }\n            features.forEach(this.forEachFeatureAdd_.bind(this));\n        }\n    };\n    /**\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n     * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     * @return {Result|null} Snap result\n     */\n    Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n        var lowerLeft = map.getCoordinateFromPixel([\n            pixel[0] - this.pixelTolerance_,\n            pixel[1] + this.pixelTolerance_,\n        ]);\n        var upperRight = map.getCoordinateFromPixel([\n            pixel[0] + this.pixelTolerance_,\n            pixel[1] - this.pixelTolerance_,\n        ]);\n        var box = boundingExtent([lowerLeft, upperRight]);\n        var segments = this.rBush_.getInExtent(box);\n        var segmentsLength = segments.length;\n        if (segmentsLength === 0) {\n            return null;\n        }\n        var projection = map.getView().getProjection();\n        var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n        var closestVertex;\n        var minSquaredDistance = Infinity;\n        var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n        var getResult = function () {\n            if (closestVertex) {\n                var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n                var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n                if (squaredPixelDistance <= squaredPixelTolerance) {\n                    return {\n                        vertex: closestVertex,\n                        vertexPixel: [\n                            Math.round(vertexPixel[0]),\n                            Math.round(vertexPixel[1]),\n                        ],\n                    };\n                }\n            }\n            return null;\n        };\n        if (this.vertex_) {\n            for (var i = 0; i < segmentsLength; ++i) {\n                var segmentData = segments[i];\n                if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n                    segmentData.segment.forEach(function (vertex) {\n                        var tempVertexCoord = fromUserCoordinate(vertex, projection);\n                        var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n                        if (delta < minSquaredDistance) {\n                            closestVertex = vertex;\n                            minSquaredDistance = delta;\n                        }\n                    });\n                }\n            }\n            var result = getResult();\n            if (result) {\n                return result;\n            }\n        }\n        if (this.edge_) {\n            for (var i = 0; i < segmentsLength; ++i) {\n                var vertex = null;\n                var segmentData = segments[i];\n                if (segmentData.feature.getGeometry().getType() === 'Circle') {\n                    var circleGeometry = segmentData.feature.getGeometry();\n                    var userProjection = getUserProjection();\n                    if (userProjection) {\n                        circleGeometry = circleGeometry\n                            .clone()\n                            .transform(userProjection, projection);\n                    }\n                    vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, \n                    /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)), projection);\n                }\n                else {\n                    var _a = segmentData.segment, segmentStart = _a[0], segmentEnd = _a[1];\n                    // points have only one coordinate\n                    if (segmentEnd) {\n                        tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n                        tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n                        vertex = closestOnSegment(projectedCoordinate, tempSegment);\n                    }\n                }\n                if (vertex) {\n                    var delta = squaredDistance(projectedCoordinate, vertex);\n                    if (delta < minSquaredDistance) {\n                        closestVertex = vertex;\n                        minSquaredDistance = delta;\n                    }\n                }\n            }\n            var result = getResult();\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @private\n     */\n    Snap.prototype.updateFeature_ = function (feature) {\n        this.removeFeature(feature, false);\n        this.addFeature(feature, false);\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentCircleGeometry_ = function (segments, geometry) {\n        var projection = this.getMap().getView().getProjection();\n        var circleGeometry = geometry;\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry.clone().transform(userProjection, projection));\n        }\n        var polygon = fromCircle(circleGeometry);\n        if (userProjection) {\n            polygon.transform(projection, userProjection);\n        }\n        var coordinates = polygon.getCoordinates()[0];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            segments.push(coordinates.slice(i, i + 2));\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentGeometryCollectionGeometry_ = function (segments, geometry) {\n        var geometries = geometry.getGeometriesArray();\n        for (var i = 0; i < geometries.length; ++i) {\n            var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n            if (segmenter) {\n                segmenter(segments, geometries[i]);\n            }\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentLineStringGeometry_ = function (segments, geometry) {\n        var coordinates = geometry.getCoordinates();\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            segments.push(coordinates.slice(i, i + 2));\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentMultiLineStringGeometry_ = function (segments, geometry) {\n        var lines = geometry.getCoordinates();\n        for (var j = 0, jj = lines.length; j < jj; ++j) {\n            var coordinates = lines[j];\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                segments.push(coordinates.slice(i, i + 2));\n            }\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentMultiPointGeometry_ = function (segments, geometry) {\n        geometry.getCoordinates().forEach(function (point) {\n            segments.push([point]);\n        });\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentMultiPolygonGeometry_ = function (segments, geometry) {\n        var polygons = geometry.getCoordinates();\n        for (var k = 0, kk = polygons.length; k < kk; ++k) {\n            var rings = polygons[k];\n            for (var j = 0, jj = rings.length; j < jj; ++j) {\n                var coordinates = rings[j];\n                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                    segments.push(coordinates.slice(i, i + 2));\n                }\n            }\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentPointGeometry_ = function (segments, geometry) {\n        segments.push([geometry.getCoordinates()]);\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.segmentPolygonGeometry_ = function (segments, geometry) {\n        var rings = geometry.getCoordinates();\n        for (var j = 0, jj = rings.length; j < jj; ++j) {\n            var coordinates = rings[j];\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                segments.push(coordinates.slice(i, i + 2));\n            }\n        }\n    };\n    return Snap;\n}(PointerInteraction));\nexport default Snap;\n//# sourceMappingURL=Snap.js.map"]},"metadata":{},"sourceType":"module"}