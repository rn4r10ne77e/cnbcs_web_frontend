{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\nvar CanvasPolygonBuilder = /** @class */function (_super) {\n  __extends(CanvasPolygonBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle !== undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   */\n  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature);\n  };\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ends, stride);\n    this.endGeometry(feature);\n  };\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(feature);\n  };\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  CanvasPolygonBuilder.prototype.finish = function () {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    var tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n    return _super.prototype.finish.call(this);\n  };\n  /**\n   * @private\n   */\n  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n  return CanvasPolygonBuilder;\n}(CanvasBuilder);\nexport default CanvasPolygonBuilder;","map":{"version":3,"sources":["../../src/render/canvas/PolygonBuilder.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction, } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\nvar CanvasPolygonBuilder = /** @class */ (function (_super) {\n    __extends(CanvasPolygonBuilder, _super);\n    /**\n     * @param {number} tolerance Tolerance.\n     * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     */\n    function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n        return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @private\n     * @return {number} End.\n     */\n    CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n        var state = this.state;\n        var fill = state.fillStyle !== undefined;\n        var stroke = state.strokeStyle !== undefined;\n        var numEnds = ends.length;\n        this.instructions.push(beginPathInstruction);\n        this.hitDetectionInstructions.push(beginPathInstruction);\n        for (var i = 0; i < numEnds; ++i) {\n            var end = ends[i];\n            var myBegin = this.coordinates.length;\n            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n            var moveToLineToInstruction = [\n                CanvasInstruction.MOVE_TO_LINE_TO,\n                myBegin,\n                myEnd,\n            ];\n            this.instructions.push(moveToLineToInstruction);\n            this.hitDetectionInstructions.push(moveToLineToInstruction);\n            if (stroke) {\n                // Performance optimization: only call closePath() when we have a stroke.\n                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n                this.instructions.push(closePathInstruction);\n                this.hitDetectionInstructions.push(closePathInstruction);\n            }\n            offset = end;\n        }\n        if (fill) {\n            this.instructions.push(fillInstruction);\n            this.hitDetectionInstructions.push(fillInstruction);\n        }\n        if (stroke) {\n            this.instructions.push(strokeInstruction);\n            this.hitDetectionInstructions.push(strokeInstruction);\n        }\n        return offset;\n    };\n    /**\n     * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     */\n    CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n        if (fillStyle === undefined && strokeStyle === undefined) {\n            return;\n        }\n        this.setFillStrokeStyles_();\n        this.beginGeometry(circleGeometry, feature);\n        if (state.fillStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_FILL_STYLE,\n                defaultFillStyle,\n            ]);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_STROKE_STYLE,\n                state.strokeStyle,\n                state.lineWidth,\n                state.lineCap,\n                state.lineJoin,\n                state.miterLimit,\n                state.lineDash,\n                state.lineDashOffset,\n            ]);\n        }\n        var flatCoordinates = circleGeometry.getFlatCoordinates();\n        var stride = circleGeometry.getStride();\n        var myBegin = this.coordinates.length;\n        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n        this.instructions.push(beginPathInstruction, circleInstruction);\n        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n        if (state.fillStyle !== undefined) {\n            this.instructions.push(fillInstruction);\n            this.hitDetectionInstructions.push(fillInstruction);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.instructions.push(strokeInstruction);\n            this.hitDetectionInstructions.push(strokeInstruction);\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n        if (fillStyle === undefined && strokeStyle === undefined) {\n            return;\n        }\n        this.setFillStrokeStyles_();\n        this.beginGeometry(polygonGeometry, feature);\n        if (state.fillStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_FILL_STYLE,\n                defaultFillStyle,\n            ]);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_STROKE_STYLE,\n                state.strokeStyle,\n                state.lineWidth,\n                state.lineCap,\n                state.lineJoin,\n                state.miterLimit,\n                state.lineDash,\n                state.lineDashOffset,\n            ]);\n        }\n        var ends = polygonGeometry.getEnds();\n        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n        var stride = polygonGeometry.getStride();\n        this.drawFlatCoordinatess_(flatCoordinates, 0, \n        /** @type {Array<number>} */ (ends), stride);\n        this.endGeometry(feature);\n    };\n    /**\n     * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n        if (fillStyle === undefined && strokeStyle === undefined) {\n            return;\n        }\n        this.setFillStrokeStyles_();\n        this.beginGeometry(multiPolygonGeometry, feature);\n        if (state.fillStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_FILL_STYLE,\n                defaultFillStyle,\n            ]);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_STROKE_STYLE,\n                state.strokeStyle,\n                state.lineWidth,\n                state.lineCap,\n                state.lineJoin,\n                state.miterLimit,\n                state.lineDash,\n                state.lineDashOffset,\n            ]);\n        }\n        var endss = multiPolygonGeometry.getEndss();\n        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n        var stride = multiPolygonGeometry.getStride();\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n    CanvasPolygonBuilder.prototype.finish = function () {\n        this.reverseHitDetectionInstructions();\n        this.state = null;\n        // We want to preserve topology when drawing polygons.  Polygons are\n        // simplified using quantization and point elimination. However, we might\n        // have received a mix of quantized and non-quantized geometries, so ensure\n        // that all are quantized by quantizing all coordinates in the batch.\n        var tolerance = this.tolerance;\n        if (tolerance !== 0) {\n            var coordinates = this.coordinates;\n            for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n                coordinates[i] = snap(coordinates[i], tolerance);\n            }\n        }\n        return _super.prototype.finish.call(this);\n    };\n    /**\n     * @private\n     */\n    CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        if (fillStyle !== undefined) {\n            this.updateFillStyle(state, this.createFill);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.updateStrokeStyle(state, this.applyStroke);\n        }\n    };\n    return CanvasPolygonBuilder;\n}(CanvasBuilder));\nexport default CanvasPolygonBuilder;\n//# sourceMappingURL=PolygonBuilder.js.map"]},"metadata":{},"sourceType":"module"}