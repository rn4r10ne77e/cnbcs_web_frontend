{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var x1 = 0;\n  var y1 = 0;\n  var segmentLength = 0;\n  var segmentM = 0;\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  var beginX = lerp(x1, x2, interpolate);\n  var beginY = lerp(y1, y2, interpolate);\n  var startOffset = offset - stride;\n  var startLength = segmentM;\n  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  var endX = lerp(x1, x2, interpolate);\n  var endY = lerp(y1, y2, interpolate);\n  // Keep text upright\n  var reverse;\n  if (rotation) {\n    var flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n  var PI = Math.PI;\n  var result = [];\n  var singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n  var previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    var x = (endX + beginX) / 2;\n    var y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n  for (var i = 0, ii = text.length; i < ii;) {\n    advance();\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n    var iStart = i;\n    var charLength = 0;\n    for (; i < ii; ++i) {\n      var index = reverse ? ii - i - 1 : i;\n      var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}","map":{"version":3,"sources":["../../src/geom/flat/textpath.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var x1 = 0;\n    var y1 = 0;\n    var segmentLength = 0;\n    var segmentM = 0;\n    function advance() {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    do {\n        advance();\n    } while (offset < end - stride && segmentM + segmentLength < startM);\n    var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n    var beginX = lerp(x1, x2, interpolate);\n    var beginY = lerp(y1, y2, interpolate);\n    var startOffset = offset - stride;\n    var startLength = segmentM;\n    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n    while (offset < end - stride && segmentM + segmentLength < endM) {\n        advance();\n    }\n    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n    var endX = lerp(x1, x2, interpolate);\n    var endY = lerp(y1, y2, interpolate);\n    // Keep text upright\n    var reverse;\n    if (rotation) {\n        var flat = [beginX, beginY, endX, endY];\n        rotate(flat, 0, 4, 2, rotation, flat, flat);\n        reverse = flat[0] > flat[2];\n    }\n    else {\n        reverse = beginX > endX;\n    }\n    var PI = Math.PI;\n    var result = [];\n    var singleSegment = startOffset + stride === offset;\n    offset = startOffset;\n    segmentLength = 0;\n    segmentM = startLength;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    var previousAngle;\n    // All on the same segment\n    if (singleSegment) {\n        advance();\n        previousAngle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            previousAngle += previousAngle > 0 ? -PI : PI;\n        }\n        var x = (endX + beginX) / 2;\n        var y = (endY + beginY) / 2;\n        result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n        return result;\n    }\n    // rendering across line segments\n    text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n    for (var i = 0, ii = text.length; i < ii;) {\n        advance();\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -PI : PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var iStart = i;\n        var charLength = 0;\n        for (; i < ii; ++i) {\n            var index = reverse ? ii - i - 1 : i;\n            var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n            if (offset + stride < end &&\n                segmentM + segmentLength < startM + charLength + len / 2) {\n                break;\n            }\n            charLength += len;\n        }\n        if (i === iStart) {\n            continue;\n        }\n        var chars = reverse\n            ? text.substring(ii - iStart, ii - i)\n            : text.substring(iStart, i);\n        interpolate =\n            segmentLength === 0\n                ? 0\n                : (startM + charLength / 2 - segmentM) / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result.push([x, y, charLength / 2, angle, chars]);\n        startM += charLength;\n    }\n    return result;\n}\n//# sourceMappingURL=textpath.js.map"]},"metadata":{},"sourceType":"module"}