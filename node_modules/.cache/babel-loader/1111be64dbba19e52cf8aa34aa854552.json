{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  var xResolution = getWidth(maxExtent) / viewportSize[0];\n  var yResolution = getHeight(maxExtent) / viewportSize[1];\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  var result = Math.min(resolution, maxResolution);\n  var ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var maxResolution = resolutions[0];\n        var minResolution = resolutions[resolutions.length - 1];\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        var capped = Math.min(cappedMaxRes, resolution);\n        var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        var tolerance = 1e-9;\n        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        var offset = -direction * (0.5 - tolerance) + 0.5;\n        var capped = Math.min(cappedMaxRes, resolution);\n        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        var newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var smooth = opt_smooth !== undefined ? opt_smooth : true;\n        if (!smooth || !opt_isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"sources":["src/resolutionconstraint.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n    var xResolution = getWidth(maxExtent) / viewportSize[0];\n    var yResolution = getHeight(maxExtent) / viewportSize[1];\n    if (showFullExtent) {\n        return Math.min(resolution, Math.max(xResolution, yResolution));\n    }\n    return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n    var result = Math.min(resolution, maxResolution);\n    var ratio = 50;\n    result *=\n        Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n            1;\n    if (minResolution) {\n        result = Math.max(result, minResolution);\n        result /=\n            Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n                ratio +\n                1;\n    }\n    return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var maxResolution = resolutions[0];\n            var minResolution = resolutions[resolutions.length - 1];\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var capped = Math.min(cappedMaxRes, resolution);\n            var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n                return resolutions[z + 1];\n            }\n            return resolutions[z];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var tolerance = 1e-9;\n            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n            var offset = -direction * (0.5 - tolerance) + 0.5;\n            var capped = Math.min(cappedMaxRes, resolution);\n            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n            var newResolution = maxResolution / Math.pow(power, zoomLevel);\n            return clamp(newResolution, minResolution, cappedMaxRes);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var smooth = opt_smooth !== undefined ? opt_smooth : true;\n            if (!smooth || !opt_isMoving) {\n                return clamp(resolution, minResolution, cappedMaxRes);\n            }\n            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=resolutionconstraint.js.map"]},"metadata":{},"sourceType":"module"}