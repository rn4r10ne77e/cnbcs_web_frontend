{"ast":null,"code":"/**\n * @module ol/MapBrowserEventHandler\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { VOID } from './functions.js';\nimport { getValues } from './obj.js';\nimport { listen, unlistenByKey } from './events.js';\nvar MapBrowserEventHandler = /** @class */function (_super) {\n  __extends(MapBrowserEventHandler, _super);\n  /**\n   * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  function MapBrowserEventHandler(map, moveTolerance) {\n    var _this = _super.call(this, map) || this;\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n    _this.map_ = map;\n    /**\n     * @type {any}\n     * @private\n     */\n    _this.clickTimeoutId_;\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    _this.emulateClicks_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.dragging_ = false;\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    _this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    _this.down_ = null;\n    var element = _this.map_.getViewport();\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    _this.activePointers_ = [];\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.originalPointerMoveEvent_;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _this);\n    /**\n     * @private\n     */\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n    return _this;\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(/** @this {MapBrowserEventHandler} */\n      function () {\n        this.clickTimeoutId_ = undefined;\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {\n    var event = pointerEvent;\n    var id = event.pointerId;\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[id];\n      for (var pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n      this.trackedTouches_[id] = event;\n    }\n    this.activePointers_ = getValues(this.trackedTouches_);\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent);\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent);\n    // Store a copy of the down event\n    this.down_ = /** @type {PointerEvent} */{};\n    for (var property in pointerEvent) {\n      var value = pointerEvent[property];\n      this.down_[property] = typeof value === 'function' ? VOID : value;\n    }\n    if (this.dragListenerKeys_.length === 0) {\n      var doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n    }\n  };\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.relayMoveEvent_ = function (pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n  };\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    var originalEvent = this.originalPointerMoveEvent_;\n    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n      event.preventDefault();\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  /**\n   * Clean up.\n   */\n  MapBrowserEventHandler.prototype.disposeInternal = function () {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return MapBrowserEventHandler;\n}(Target);\nexport default MapBrowserEventHandler;","map":{"version":3,"sources":["src/MapBrowserEventHandler.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { VOID } from './functions.js';\nimport { getValues } from './obj.js';\nimport { listen, unlistenByKey } from './events.js';\nvar MapBrowserEventHandler = /** @class */ (function (_super) {\n    __extends(MapBrowserEventHandler, _super);\n    /**\n     * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n     */\n    function MapBrowserEventHandler(map, moveTolerance) {\n        var _this = _super.call(this, map) || this;\n        /**\n         * This is the element that we will listen to the real events on.\n         * @type {import(\"./PluggableMap.js\").default}\n         * @private\n         */\n        _this.map_ = map;\n        /**\n         * @type {any}\n         * @private\n         */\n        _this.clickTimeoutId_;\n        /**\n         * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n         * @type {boolean}\n         */\n        _this.emulateClicks_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.dragging_ = false;\n        /**\n         * @type {!Array<import(\"./events.js\").EventsKey>}\n         * @private\n         */\n        _this.dragListenerKeys_ = [];\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n        /**\n         * The most recent \"down\" type event (or null if none have occurred).\n         * Set on pointerdown.\n         * @type {PointerEvent|null}\n         * @private\n         */\n        _this.down_ = null;\n        var element = _this.map_.getViewport();\n        /**\n         * @type {Array<PointerEvent>}\n         * @private\n         */\n        _this.activePointers_ = [];\n        /**\n         * @type {!Object<number, Event>}\n         * @private\n         */\n        _this.trackedTouches_ = {};\n        _this.element_ = element;\n        /**\n         * @type {?import(\"./events.js\").EventsKey}\n         * @private\n         */\n        _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);\n        /**\n         * @type {PointerEvent}\n         * @private\n         */\n        _this.originalPointerMoveEvent_;\n        /**\n         * @type {?import(\"./events.js\").EventsKey}\n         * @private\n         */\n        _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _this);\n        /**\n         * @private\n         */\n        _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n        _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);\n        return _this;\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n        if (this.clickTimeoutId_ !== undefined) {\n            // double-click\n            clearTimeout(this.clickTimeoutId_);\n            this.clickTimeoutId_ = undefined;\n            newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n            this.dispatchEvent(newEvent);\n        }\n        else {\n            // click\n            this.clickTimeoutId_ = setTimeout(\n            /** @this {MapBrowserEventHandler} */\n            function () {\n                this.clickTimeoutId_ = undefined;\n                var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n                this.dispatchEvent(newEvent);\n            }.bind(this), 250);\n        }\n    };\n    /**\n     * Keeps track on how many pointers are currently active.\n     *\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {\n        var event = pointerEvent;\n        var id = event.pointerId;\n        if (event.type == MapBrowserEventType.POINTERUP ||\n            event.type == MapBrowserEventType.POINTERCANCEL) {\n            delete this.trackedTouches_[id];\n            for (var pointerId in this.trackedTouches_) {\n                if (this.trackedTouches_[pointerId].target !== event.target) {\n                    // Some platforms assign a new pointerId when the target changes.\n                    // If this happens, delete one tracked pointer. If there is more\n                    // than one tracked pointer for the old target, it will be cleared\n                    // by subsequent POINTERUP events from other pointers.\n                    delete this.trackedTouches_[pointerId];\n                    break;\n                }\n            }\n        }\n        else if (event.type == MapBrowserEventType.POINTERDOWN ||\n            event.type == MapBrowserEventType.POINTERMOVE) {\n            this.trackedTouches_[id] = event;\n        }\n        this.activePointers_ = getValues(this.trackedTouches_);\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {\n        this.updateActivePointers_(pointerEvent);\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n        this.dispatchEvent(newEvent);\n        // We emulate click events on left mouse button click, touch contact, and pen\n        // contact. isMouseActionButton returns true in these cases (evt.button is set\n        // to 0).\n        // See http://www.w3.org/TR/pointerevents/#button-states\n        // We only fire click, singleclick, and doubleclick if nobody has called\n        // event.preventDefault().\n        if (this.emulateClicks_ &&\n            !newEvent.defaultPrevented &&\n            !this.dragging_ &&\n            this.isMouseActionButton_(pointerEvent)) {\n            this.emulateClick_(this.down_);\n        }\n        if (this.activePointers_.length === 0) {\n            this.dragListenerKeys_.forEach(unlistenByKey);\n            this.dragListenerKeys_.length = 0;\n            this.dragging_ = false;\n            this.down_ = null;\n        }\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} If the left mouse button was pressed.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {\n        return pointerEvent.button === 0;\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {\n        this.emulateClicks_ = this.activePointers_.length === 0;\n        this.updateActivePointers_(pointerEvent);\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n        this.dispatchEvent(newEvent);\n        // Store a copy of the down event\n        this.down_ = /** @type {PointerEvent} */ ({});\n        for (var property in pointerEvent) {\n            var value = pointerEvent[property];\n            this.down_[property] = typeof value === 'function' ? VOID : value;\n        }\n        if (this.dragListenerKeys_.length === 0) {\n            var doc = this.map_.getOwnerDocument();\n            this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), \n            /* Note that the listener for `pointercancel is set up on\n             * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n             * the `pointerup` and `pointermove` listeners.\n             *\n             * The reason for this is the following: `TouchSource.vacuumTouches_()`\n             * issues `pointercancel` events, when there was no `touchend` for a\n             * `touchstart`. Now, let's say a first `touchstart` is registered on\n             * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n             * But `documentPointerEventHandler_` doesn't know about the first\n             * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n             * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n             * only registered there.\n             */\n            listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n                this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n            }\n        }\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {\n        // Between pointerdown and pointerup, pointermove events are triggered.\n        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n        // moved a significant distance.\n        if (this.isMoving_(pointerEvent)) {\n            this.updateActivePointers_(pointerEvent);\n            this.dragging_ = true;\n            var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n            this.dispatchEvent(newEvent);\n        }\n    };\n    /**\n     * Wrap and relay a pointermove event.\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.relayMoveEvent_ = function (pointerEvent) {\n        this.originalPointerMoveEvent_ = pointerEvent;\n        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n        this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n    };\n    /**\n     * Flexible handling of a `touch-action: none` css equivalent: because calling\n     * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n     * when an interaction (currently `DragPan` handles the event.\n     * @param {TouchEvent} event Event.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {\n        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n        // may not be initialized yet when we get here on a platform without native pointer events.\n        var originalEvent = this.originalPointerMoveEvent_;\n        if ((!originalEvent || originalEvent.defaultPrevented) &&\n            (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n            event.preventDefault();\n        }\n    };\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} Is moving.\n     * @private\n     */\n    MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {\n        return (this.dragging_ ||\n            Math.abs(pointerEvent.clientX - this.down_.clientX) >\n                this.moveTolerance_ ||\n            Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);\n    };\n    /**\n     * Clean up.\n     */\n    MapBrowserEventHandler.prototype.disposeInternal = function () {\n        if (this.relayedListenerKey_) {\n            unlistenByKey(this.relayedListenerKey_);\n            this.relayedListenerKey_ = null;\n        }\n        this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n        if (this.pointerdownListenerKey_) {\n            unlistenByKey(this.pointerdownListenerKey_);\n            this.pointerdownListenerKey_ = null;\n        }\n        this.dragListenerKeys_.forEach(unlistenByKey);\n        this.dragListenerKeys_.length = 0;\n        this.element_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return MapBrowserEventHandler;\n}(Target));\nexport default MapBrowserEventHandler;\n//# sourceMappingURL=MapBrowserEventHandler.js.map"]},"metadata":{},"sourceType":"module"}