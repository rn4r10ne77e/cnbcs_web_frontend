{"ast":null,"code":"/**\n * @module ol/color\n */\nimport { createCanvasContext2D } from './dom.js';\nimport { clamp, toFixed } from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Color to indicate that no color should be rendered. This is meant to be used for per-reference\n * comparisons only.\n * @type {Color}\n */\nexport const NO_COLOR = [NaN, NaN, NaN, 0];\nlet colorParseContext;\n/**\n * @return {CanvasRenderingContext2D} The color parse context\n */\nfunction getColorParseContext() {\n  if (!colorParseContext) {\n    colorParseContext = createCanvasContext2D(1, 1, undefined, {\n      willReadFrequently: true,\n      desynchronized: true\n    });\n  }\n  return colorParseContext;\n}\nconst rgbModernRegEx = /^rgba?\\(\\s*(\\d+%?)\\s+(\\d+%?)\\s+(\\d+%?)(?:\\s*\\/\\s*(\\d+%|\\d*\\.\\d+|[01]))?\\s*\\)$/i;\nconst rgbLegacyAbsoluteRegEx = /^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d+%|\\d*\\.\\d+|[01]))?\\s*\\)$/i;\nconst rgbLegacyPercentageRegEx = /^rgba?\\(\\s*(\\d+%)\\s*,\\s*(\\d+%)\\s*,\\s*(\\d+%)(?:\\s*,\\s*(\\d+%|\\d*\\.\\d+|[01]))?\\s*\\)$/i;\nconst hexRegEx = /^#([\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/i;\n\n/**\n * @param {string} s Color component as number or percentage.\n * @param {number} divider Divider for percentage.\n * @return {number} Color component.\n */\nfunction toColorComponent(s, divider) {\n  return s.endsWith('%') ? Number(s.substring(0, s.length - 1)) / divider : Number(s);\n}\n\n/**\n * @param {string} color Color string.\n */\nfunction throwInvalidColor(color) {\n  throw new Error('failed to parse \"' + color + '\" as color');\n}\n\n/**\n * @param {string} color Color string.\n * @return {Color} RGBa color array.\n */\nfunction parseRgba(color) {\n  // Fast lane for rgb(a) colors\n  if (color.toLowerCase().startsWith('rgb')) {\n    const rgb = color.match(rgbLegacyAbsoluteRegEx) || color.match(rgbModernRegEx) || color.match(rgbLegacyPercentageRegEx);\n    if (rgb) {\n      const alpha = rgb[4];\n      const rgbDivider = 100 / 255;\n      return [clamp(toColorComponent(rgb[1], rgbDivider) + 0.5 | 0, 0, 255), clamp(toColorComponent(rgb[2], rgbDivider) + 0.5 | 0, 0, 255), clamp(toColorComponent(rgb[3], rgbDivider) + 0.5 | 0, 0, 255), alpha !== undefined ? clamp(toColorComponent(alpha, 100), 0, 1) : 1];\n    }\n    throwInvalidColor(color);\n  }\n  // Fast lane for hex colors (also with alpha)\n  if (color.startsWith('#')) {\n    if (hexRegEx.test(color)) {\n      const hex = color.substring(1);\n      const step = hex.length <= 4 ? 1 : 2;\n      const colorFromHex = [0, 0, 0, 255];\n      for (let i = 0, ii = hex.length; i < ii; i += step) {\n        let colorComponent = parseInt(hex.substring(i, i + step), 16);\n        if (step === 1) {\n          colorComponent += colorComponent << 4;\n        }\n        colorFromHex[i / step] = colorComponent;\n      }\n      colorFromHex[3] = colorFromHex[3] / 255;\n      return colorFromHex;\n    }\n    throwInvalidColor(color);\n  }\n  // Use canvas color serialization to parse the color into hex or rgba\n  // See https://www.w3.org/TR/2021/SPSD-2dcontext-20210128/#serialization-of-a-color\n  const context = getColorParseContext();\n  context.fillStyle = '#abcdef';\n  let invalidCheckFillStyle = context.fillStyle;\n  context.fillStyle = color;\n  if (context.fillStyle === invalidCheckFillStyle) {\n    context.fillStyle = '#fedcba';\n    invalidCheckFillStyle = context.fillStyle;\n    context.fillStyle = color;\n    if (context.fillStyle === invalidCheckFillStyle) {\n      throwInvalidColor(color);\n    }\n  }\n  const colorString = context.fillStyle;\n  if (colorString.startsWith('#') || colorString.startsWith('rgba')) {\n    return parseRgba(colorString);\n  }\n  context.clearRect(0, 0, 1, 1);\n  context.fillRect(0, 0, 1, 1);\n  const colorFromImage = Array.from(context.getImageData(0, 0, 1, 1).data);\n  colorFromImage[3] = toFixed(colorFromImage[3] / 255, 3);\n  return colorFromImage;\n}\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * @type {number}\n */\nconst MAX_CACHE_SIZE = 1024;\n\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\nconst cache = {};\n\n/**\n * @type {number}\n */\nlet cacheSize = 0;\n\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n\n// The functions b1, b2, a1, a2, rgbaToLcha and lchaToRgba below are adapted from\n// https://stackoverflow.com/a/67219995/2389327\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction b1(v) {\n  return v > 0.0031308 ? Math.pow(v, 1 / 2.4) * 269.025 - 14.025 : v * 3294.6;\n}\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction b2(v) {\n  return v > 0.2068965 ? Math.pow(v, 3) : (v - 4 / 29) * (108 / 841);\n}\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction a1(v) {\n  return v > 10.314724 ? Math.pow((v + 14.025) / 269.025, 2.4) : v / 3294.6;\n}\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction a2(v) {\n  return v > 0.0088564 ? Math.pow(v, 1 / 3) : v / (108 / 841) + 4 / 29;\n}\n\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\nexport function rgbaToLcha(color) {\n  const r = a1(color[0]);\n  const g = a1(color[1]);\n  const b = a1(color[2]);\n  const y = a2(r * 0.222488403 + g * 0.716873169 + b * 0.06060791);\n  const l = 500 * (a2(r * 0.452247074 + g * 0.399439023 + b * 0.148375274) - y);\n  const q = 200 * (y - a2(r * 0.016863605 + g * 0.117638439 + b * 0.865350722));\n  const h = Math.atan2(q, l) * (180 / Math.PI);\n  return [116 * y - 16, Math.sqrt(l * l + q * q), h < 0 ? h + 360 : h, color[3]];\n}\n\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\nexport function lchaToRgba(color) {\n  const l = (color[0] + 16) / 116;\n  const c = color[1];\n  const h = color[2] * Math.PI / 180;\n  const y = b2(l);\n  const x = b2(l + c / 500 * Math.cos(h));\n  const z = b2(l - c / 200 * Math.sin(h));\n  const r = b1(x * 3.021973625 - y * 1.617392459 - z * 0.404875592);\n  const g = b1(x * -0.943766287 + y * 1.916279586 + z * 0.027607165);\n  const b = b1(x * 0.069407491 - y * 0.22898585 + z * 1.159737864);\n  return [clamp(r + 0.5 | 0, 0, 255), clamp(g + 0.5 | 0, 0, 255), clamp(b + 0.5 | 0, 0, 255), color[3]];\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport function fromString(s) {\n  if (s === 'none') {\n    return NO_COLOR;\n  }\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n  const color = parseRgba(s);\n  if (color.length !== 4) {\n    throwInvalidColor(s);\n  }\n  for (const c of color) {\n    if (isNaN(c)) {\n      throwInvalidColor(s);\n    }\n  }\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch {\n    return false;\n  }\n}","map":{"version":3,"names":["createCanvasContext2D","clamp","toFixed","NO_COLOR","NaN","colorParseContext","getColorParseContext","undefined","willReadFrequently","desynchronized","rgbModernRegEx","rgbLegacyAbsoluteRegEx","rgbLegacyPercentageRegEx","hexRegEx","toColorComponent","s","divider","endsWith","Number","substring","length","throwInvalidColor","color","Error","parseRgba","toLowerCase","startsWith","rgb","match","alpha","rgbDivider","test","hex","step","colorFromHex","i","ii","colorComponent","parseInt","context","fillStyle","invalidCheckFillStyle","colorString","clearRect","fillRect","colorFromImage","Array","from","getImageData","data","asString","toString","MAX_CACHE_SIZE","cache","cacheSize","withAlpha","output","slice","b1","v","Math","pow","b2","a1","a2","rgbaToLcha","r","g","b","y","l","q","h","atan2","PI","sqrt","lchaToRgba","c","x","cos","z","sin","fromString","hasOwnProperty","key","isNaN","asArray","isArray","a","round","isStringColor"],"sources":["C:/prj/cnbcs_web_frontend/node_modules/ol/color.js"],"sourcesContent":["/**\n * @module ol/color\n */\nimport {createCanvasContext2D} from './dom.js';\nimport {clamp, toFixed} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Color to indicate that no color should be rendered. This is meant to be used for per-reference\n * comparisons only.\n * @type {Color}\n */\nexport const NO_COLOR = [NaN, NaN, NaN, 0];\n\nlet colorParseContext;\n/**\n * @return {CanvasRenderingContext2D} The color parse context\n */\nfunction getColorParseContext() {\n  if (!colorParseContext) {\n    colorParseContext = createCanvasContext2D(1, 1, undefined, {\n      willReadFrequently: true,\n      desynchronized: true,\n    });\n  }\n  return colorParseContext;\n}\n\nconst rgbModernRegEx =\n  /^rgba?\\(\\s*(\\d+%?)\\s+(\\d+%?)\\s+(\\d+%?)(?:\\s*\\/\\s*(\\d+%|\\d*\\.\\d+|[01]))?\\s*\\)$/i;\nconst rgbLegacyAbsoluteRegEx =\n  /^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d+%|\\d*\\.\\d+|[01]))?\\s*\\)$/i;\nconst rgbLegacyPercentageRegEx =\n  /^rgba?\\(\\s*(\\d+%)\\s*,\\s*(\\d+%)\\s*,\\s*(\\d+%)(?:\\s*,\\s*(\\d+%|\\d*\\.\\d+|[01]))?\\s*\\)$/i;\nconst hexRegEx = /^#([\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/i;\n\n/**\n * @param {string} s Color component as number or percentage.\n * @param {number} divider Divider for percentage.\n * @return {number} Color component.\n */\nfunction toColorComponent(s, divider) {\n  return s.endsWith('%')\n    ? Number(s.substring(0, s.length - 1)) / divider\n    : Number(s);\n}\n\n/**\n * @param {string} color Color string.\n */\nfunction throwInvalidColor(color) {\n  throw new Error('failed to parse \"' + color + '\" as color');\n}\n\n/**\n * @param {string} color Color string.\n * @return {Color} RGBa color array.\n */\nfunction parseRgba(color) {\n  // Fast lane for rgb(a) colors\n  if (color.toLowerCase().startsWith('rgb')) {\n    const rgb =\n      color.match(rgbLegacyAbsoluteRegEx) ||\n      color.match(rgbModernRegEx) ||\n      color.match(rgbLegacyPercentageRegEx);\n    if (rgb) {\n      const alpha = rgb[4];\n      const rgbDivider = 100 / 255;\n      return [\n        clamp((toColorComponent(rgb[1], rgbDivider) + 0.5) | 0, 0, 255),\n        clamp((toColorComponent(rgb[2], rgbDivider) + 0.5) | 0, 0, 255),\n        clamp((toColorComponent(rgb[3], rgbDivider) + 0.5) | 0, 0, 255),\n        alpha !== undefined ? clamp(toColorComponent(alpha, 100), 0, 1) : 1,\n      ];\n    }\n    throwInvalidColor(color);\n  }\n  // Fast lane for hex colors (also with alpha)\n  if (color.startsWith('#')) {\n    if (hexRegEx.test(color)) {\n      const hex = color.substring(1);\n      const step = hex.length <= 4 ? 1 : 2;\n      const colorFromHex = [0, 0, 0, 255];\n      for (let i = 0, ii = hex.length; i < ii; i += step) {\n        let colorComponent = parseInt(hex.substring(i, i + step), 16);\n        if (step === 1) {\n          colorComponent += colorComponent << 4;\n        }\n        colorFromHex[i / step] = colorComponent;\n      }\n      colorFromHex[3] = colorFromHex[3] / 255;\n      return colorFromHex;\n    }\n    throwInvalidColor(color);\n  }\n  // Use canvas color serialization to parse the color into hex or rgba\n  // See https://www.w3.org/TR/2021/SPSD-2dcontext-20210128/#serialization-of-a-color\n  const context = getColorParseContext();\n  context.fillStyle = '#abcdef';\n  let invalidCheckFillStyle = context.fillStyle;\n  context.fillStyle = color;\n  if (context.fillStyle === invalidCheckFillStyle) {\n    context.fillStyle = '#fedcba';\n    invalidCheckFillStyle = context.fillStyle;\n    context.fillStyle = color;\n    if (context.fillStyle === invalidCheckFillStyle) {\n      throwInvalidColor(color);\n    }\n  }\n  const colorString = context.fillStyle;\n  if (colorString.startsWith('#') || colorString.startsWith('rgba')) {\n    return parseRgba(colorString);\n  }\n  context.clearRect(0, 0, 1, 1);\n  context.fillRect(0, 0, 1, 1);\n  const colorFromImage = Array.from(context.getImageData(0, 0, 1, 1).data);\n  colorFromImage[3] = toFixed(colorFromImage[3] / 255, 3);\n  return colorFromImage;\n}\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * @type {number}\n */\nconst MAX_CACHE_SIZE = 1024;\n\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\nconst cache = {};\n\n/**\n * @type {number}\n */\nlet cacheSize = 0;\n\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n\n// The functions b1, b2, a1, a2, rgbaToLcha and lchaToRgba below are adapted from\n// https://stackoverflow.com/a/67219995/2389327\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction b1(v) {\n  return v > 0.0031308 ? Math.pow(v, 1 / 2.4) * 269.025 - 14.025 : v * 3294.6;\n}\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction b2(v) {\n  return v > 0.2068965 ? Math.pow(v, 3) : (v - 4 / 29) * (108 / 841);\n}\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction a1(v) {\n  return v > 10.314724 ? Math.pow((v + 14.025) / 269.025, 2.4) : v / 3294.6;\n}\n\n/**\n * @param {number} v Input value.\n * @return {number} Output value.\n */\nfunction a2(v) {\n  return v > 0.0088564 ? Math.pow(v, 1 / 3) : v / (108 / 841) + 4 / 29;\n}\n\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\nexport function rgbaToLcha(color) {\n  const r = a1(color[0]);\n  const g = a1(color[1]);\n  const b = a1(color[2]);\n  const y = a2(r * 0.222488403 + g * 0.716873169 + b * 0.06060791);\n  const l = 500 * (a2(r * 0.452247074 + g * 0.399439023 + b * 0.148375274) - y);\n  const q = 200 * (y - a2(r * 0.016863605 + g * 0.117638439 + b * 0.865350722));\n  const h = Math.atan2(q, l) * (180 / Math.PI);\n  return [\n    116 * y - 16,\n    Math.sqrt(l * l + q * q),\n    h < 0 ? h + 360 : h,\n    color[3],\n  ];\n}\n\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\nexport function lchaToRgba(color) {\n  const l = (color[0] + 16) / 116;\n  const c = color[1];\n  const h = (color[2] * Math.PI) / 180;\n  const y = b2(l);\n  const x = b2(l + (c / 500) * Math.cos(h));\n  const z = b2(l - (c / 200) * Math.sin(h));\n  const r = b1(x * 3.021973625 - y * 1.617392459 - z * 0.404875592);\n  const g = b1(x * -0.943766287 + y * 1.916279586 + z * 0.027607165);\n  const b = b1(x * 0.069407491 - y * 0.22898585 + z * 1.159737864);\n  return [\n    clamp((r + 0.5) | 0, 0, 255),\n    clamp((g + 0.5) | 0, 0, 255),\n    clamp((b + 0.5) | 0, 0, 255),\n    color[3],\n  ];\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport function fromString(s) {\n  if (s === 'none') {\n    return NO_COLOR;\n  }\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n\n  const color = parseRgba(s);\n  if (color.length !== 4) {\n    throwInvalidColor(s);\n  }\n  for (const c of color) {\n    if (isNaN(c)) {\n      throwInvalidColor(s);\n    }\n  }\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch {\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}